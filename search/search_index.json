{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JavaScript Mastery JavaScript is the backbone of modern web development. Whether you're a beginner taking your first steps or an experienced coder looking to sharpen your skills, this website will guide you through the world of JavaScript. JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g. functional programming) styles. Topic Description Introduction to JavaScript Understanding syntax, variables, and data types. Functions and Scope Mastering functions, closures, and scope. DOM Manipulation How JavaScript interacts with HTML and CSS. Event Handling Making web pages interactive with events. Asynchronous JavaScript Understanding callbacks, promises, and async/await. Object-Oriented JavaScript Exploring prototypes, classes, and inheritance. JavaScript Frameworks Overview of React, Vue, and Angular. Advanced Concepts Performance optimization, design patterns, and best practices. References JavaScript Guide Contribute Help us improve this tutorial! If you find any issues or have suggestions, please report them on our GitHub repository .","title":"Home"},{"location":"#javascript-mastery","text":"JavaScript is the backbone of modern web development. Whether you're a beginner taking your first steps or an experienced coder looking to sharpen your skills, this website will guide you through the world of JavaScript. JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g. functional programming) styles. Topic Description Introduction to JavaScript Understanding syntax, variables, and data types. Functions and Scope Mastering functions, closures, and scope. DOM Manipulation How JavaScript interacts with HTML and CSS. Event Handling Making web pages interactive with events. Asynchronous JavaScript Understanding callbacks, promises, and async/await. Object-Oriented JavaScript Exploring prototypes, classes, and inheritance. JavaScript Frameworks Overview of React, Vue, and Angular. Advanced Concepts Performance optimization, design patterns, and best practices.","title":"JavaScript Mastery"},{"location":"#references","text":"JavaScript Guide","title":"References"},{"location":"#contribute","text":"Help us improve this tutorial! If you find any issues or have suggestions, please report them on our GitHub repository .","title":"Contribute"},{"location":"js_ECMAScript6/","text":"ECMAScript (ES) is a scripting language specification created to standardize JavaScript. The Sixth Edition, initially known as ECMAScript 6 (ES6) and later renamed to ECMAScript 2015, adds significant new syntax for writing complex applications, including classes and modules, iterators and for/of loops, generators, arrow functions, binary data, typed arrays, collections (maps, sets and weak maps), promises, number and math enhancements, reflection, and proxies. In other words, ES6 is a superset of JavaScript (ES5). The reason that ES6 became so popular is that it introduced new conventions and OOP concepts such as classes. Variable Declaration In ES6 we have three ways of declaring variables: var x = 5 ; let y = 5 ; const z = 5 ; The type of declaration used depends on the necessary scope. Scope is the fundamental concept in all programming languages that defines the visibility of a variable. var & let Unlike the var keyword, which defines a variable globally, or locally to an entire function regardless of block scope, let allows you to declare variables that are limited in scope to the block, statement, or expression in which they are used. if ( true ){ let name = 'Jack' ; } alert ( name ); //generates error In this case, the name variable is accessible only in the scope of the if statement because it was declared as let. To demonstrate the difference in scope between var and let, consider this example: function varTest (){ var x = 1 ; if ( true ){ var x = 2 ; // same variable console . log ( x ); // 2 } console . log ( x ); //2 } function letTest (){ let x = 1 ; if ( true ){ let x = 2 ; // different variable console . log ( x ); // 2 } console . log ( x ); //1 } varTest (); letTest (); One of the best uses for let is in loops: for ( let i = 0 ; i < 10 ; i ++ ){ console . log ( i ); } let is not subject to Variable Hoisting, which means that let declarations do not move to the top of the current execution context. const const variables have the same scope as variables declared using let. The difference is that const variables are immutable - they are not allowed to be reassigned. For example, the following generates an exception: const x = 5 ; x = 6 ; const is not subject to Variable Hoisting too, which means that const declarations do not move to the top of the current execution context. Also note that ES6 code will run only in browsers that support it. Older devices and browsers that do not support ES6 will return a syntax error. Template Literals in ES6 Template literals are a way to output variables in the string. Prior to ES6 we had to break the string, for example: var name = 'John' ; var text = 'My name is ' + name ; Now we can use template literals: var name = 'John' ; var text = `My name is ${ name } ` ; Notice that template literals are enclosed by the backtick ( ) character instead of double or single quotes. The ${expression} is a placeholder, and can include any expression, which will get evaluated and inserted into the template literal. let a = 8 ; let b = 3 ; let msg = `The sum is ${ a + b } !` ; console . log ( msg ); To escape a backtick in a template literal, put a backslash \\ before the backtick. Loops In JavaScript we commonly use the for loop to iterate over values in a list: let arr = [ 1 , 2 , 3 ]; for ( let k = 0 ; k < arr . length ; k ++ ){ console . log ( arr [ k ]); } For..in loop The for...in loop is intended for iterating over the enumerable keys of an object. For example: let obj = { a : 1 , b : 2 , c : 3 }; for ( let v in obj ){ console . log ( v ); } The for...in loop should NOT be used to iterate over arrays because, depending on the JavaScript engine, it could iterate in an arbitrary order. Also, the iterating variable is a string, not a number, so if you try to do any math with the variable, you'll be performing string concatenation instead of addition. For...of loop ES6 introduces the new for...of loop, which creates a loop iterating over iterable objects. For example: let list = [ \"x\" , \"y\" , \"z\" ]; for ( let val of list ){ console . log ( val ); } During each iteration the val variable is assigned the corresponding element in the list. The for...of loop works for other iterable objects as well, including strings for ( let val of \"Hello\" ){ console . log ( val ); } The for...of loop also works on the newly introduced collections (Map, Set, WeakMap, and WeakSet). Functions in ECMAScript 6 Prior to ES6, a JavaScript function was defined like this: function add ( x , y ){ var sum = x + y ; console . log ( sum ); } ES6 introduces a new syntax for writing functions. The same function from above can be written as: const add = ( x , y ) => { let sum = x + y ; console . log ( sum ); } This new syntax is quite handy when you just need a simple function with one argument. You can skip typing function and return, as well as some parentheses and braces. For example: const greet = x => \"Welcome \" + x ; console . log ( greet ( \"John\" )); The code above defines a function named greet that has one argument and returns a message. If there are no parameters, an empty pair of parentheses should be used, as in const x = () => alert ( \"Hi\" ); The syntax is very useful for inline functions. For example, let's say we have an array, and for each element of the array we need to execute a function. We use the forEach method of the array to call a function for each element: var arr = [ 2 , 3 , 7 , 8 ]; arr . forEach ( function ( el ) { console . log ( el * 2 ); }); However, in ES6, the code above can be rewritten as following: var arr = [ 2 , 3 , 7 , 8 ]; arr . forEach ( v => { console . log ( v * 2 ); }); Default Parameters in ES6 In ES6, we can put the default values right in the signature of the functions. function test ( a , b = 3 , c = 42 ){ return a + b + c ; } console . log ( test ( 5 )); //50 And here's an example of an arrow function with default parameters: const test = ( a , b = 3 , c = 42 ) => { return a + b + c ; } console . log ( test ( 5 )); //50 Default value expressions are evaluated at function call time from left to right. This also means that default expressions can use the values of previously-filled parameters. ES6 Objects JavaScript variables can be Object data types that contain many values called properties. An object can also have properties that are function definitions called methods for performing actions on the object. ES6 introduces shorthand notations and computed property names that make declaring and using objects easier to understand. The new method definition shorthand does not require the colon (:) or function keyword, as in the grow function of the tree object declaration: let tree = { height : 10 , color : 'green' , grow () { this . height += 2 ; } }; tree . grow (); console . log ( tree . height ); //12 You can also use a property value shorthand when initializing properties with a variable by the same name. For example, properties height and health are being initialized with variables named height and health let height = 5 ; let health = 100 ; let athlete = { height , health }; console . log ( athlete . height ); //5 console . log ( athlete . health ); //100 When creating an object by using duplicate property names, the last property will overwrite the prior ones of the same name. For Example: var a = { x : 1 , x : 2 , x : 3 , x : 4 }; console . log ( a . x ); //4 Duplicate property names generated a SyntaxError in ES5 when using strict mode. However, ES6 removed this limitation. Computed Property Names With ES6, you can now use computed property names. Using the square bracket notation [], we can use an expression for a property name, including concatenating strings. This can be useful in cases where we want to create certain objects based on user data (e.g. id, email, and so on). It is very useful when you need to create custom objects based on some variables. Here are three examples: Example 1 let prop = 'name' ; let id = '1234' ; let mobile = '12345678' ; let user = { [ prop ] : 'Jack' , [ `user_ ${ id } ` ] : ` ${ mobile } ` }; Example 2 var i = 0 ; var a = { [ 'foo' + ++ i ] : i , [ 'foo' + ++ i ] : i , [ 'foo' + ++ i ] : i }; Example 3 var param = 'size' ; var config = { [ param ] : 12 , [ 'mobile' + param . charAt ( 0 ). toUpperCase () + param . slice ( 1 )] : 4 }; console . log ( config . mobileSize ); Object.assign() in ES6 ES6 adds a new Object method assign() that allows us to combine multiple sources into one target to create a single new object. Object.assign() is also useful for creating a duplicate of an existing object. Let's look at the following example to see how to combine objects: let person = { name : 'Jack' , age : 18 , sex : 'male' }; let student = { name : 'Bob' , age : 20 , xp : '2' }; let student = Object . assign ({}, person , student ); Here we used Object.assign() where the first parameter is the target object you want to apply new properties to. Every parameter after the first will be used as sources for the target. There are no limitations on the number of source parameters. However, order is important because properties in the second parameter will be overridden by properties of the same name in third parameter, and so on. In the example above, we used a new object {} as the target and used two objects as sources. Now, let's see how we can use assign() to create a duplicate object without creating a reference (mutating) to the base object. In the following example, assignment was used to try to generate a new object. However, using = creates a reference to the base object. Because of this reference, changes intended for a new object mutate the original object: let person = { name : 'Jack' , age : 18 }; let newPerson = person ; //newPerson references person newPerson . name = 'Bob' ; console . log ( person . name ); //Bob console . log ( newPerson . name ); //Bob To avoid this (mutations), use Object.assign() to create a new object. For example: let person = { name : 'Jack' , age : 18 }; let newPerson = Object . assign ({}, person ); newPerson . name = 'Bob' ; console . log ( person . name ); //Jack console . log ( newPerson . name ); //Bob Finally, you can assign a value to an object property in the Object.assign() statement. For example: let person = { name : 'Jack' , age : 18 }; let newPerson = Object . assign ({}, person , { name : 'Bob' }); console . log ( person . name ); //Jack console . log ( newPerson . name ); //Bob Array Destructuring in ES6 The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables. ES6 has added a shorthand syntax for destructuring an array. The following example demonstrates how to unpack the elements of an array into distinct variables: let arr = [ '1' , '2' , '3' ]; let [ one , two , three ] = arr ; console . log ( one ); //1 console . log ( two ); //2 console . log ( three ); //3 We can also destructure an array returned by a function. let a = () => { return [ 1 , 2 , 3 ]; }; let [ one ,, two ] = a (); console . log ( one ); //1 console . log ( two ); //3 Notice that we left the second argument's place empty. The destructuring syntax also simplifies assignment and swapping values: let a , b , c = 4 , d = 8 ; [ a , b = 6 ] = [ 2 ]; // a=2, b=6 [ c , d ] = [ d , c ]; // c=8, d = 4 console . log ( a ); //2 console . log ( b ); //6 console . log ( c ); //4 console . log ( d ); //8 Object Destructuring in ES6 Similar to Array destructuring, Object destructuring unpacks properties into distinct variables. For example: let obj = { h : 100 , s : true }; let { h , s } = obj ; console . log ( h ); //100 console . log ( s ); //true We can assign without declaration, but there are some syntax requirements for that: For example: let a , b ; ({ a , b } = { a : 'Hello' , b : 'world!' }); console . log ( a ); //Hello console . log ( b ); //world! The () with a semicolon (;) at the end are mandatory when destructuring without a declaration. However, you can also do it as follows where the () are not required: let { a , b } = { a : 'Hello' , b : 'world!' }; console . log ( a ); //Hello console . log ( b ); //world! You can also assign the object to new variable names. For example: var o = { h : 42 , s : true }; var { h : foo , s : bar } = o ; //console.log(h); //Error console . log ( foo ); //42 console . log ( bar ); //true Finally you can assign default values to variables, in case the value unpacked from the object is undefined. For example: var obj = { id : 42 , name : 'Carlos' }; let { id = 10 , age = 20 } = obj ; console . log ( id ); //42 console . log ( age ); //20 ES6 Rest Parameters","title":"ECMAScript 6"},{"location":"js_ECMAScript6/#variable-declaration","text":"In ES6 we have three ways of declaring variables: var x = 5 ; let y = 5 ; const z = 5 ; The type of declaration used depends on the necessary scope. Scope is the fundamental concept in all programming languages that defines the visibility of a variable.","title":"Variable Declaration"},{"location":"js_ECMAScript6/#var-let","text":"Unlike the var keyword, which defines a variable globally, or locally to an entire function regardless of block scope, let allows you to declare variables that are limited in scope to the block, statement, or expression in which they are used. if ( true ){ let name = 'Jack' ; } alert ( name ); //generates error In this case, the name variable is accessible only in the scope of the if statement because it was declared as let. To demonstrate the difference in scope between var and let, consider this example: function varTest (){ var x = 1 ; if ( true ){ var x = 2 ; // same variable console . log ( x ); // 2 } console . log ( x ); //2 } function letTest (){ let x = 1 ; if ( true ){ let x = 2 ; // different variable console . log ( x ); // 2 } console . log ( x ); //1 } varTest (); letTest (); One of the best uses for let is in loops: for ( let i = 0 ; i < 10 ; i ++ ){ console . log ( i ); } let is not subject to Variable Hoisting, which means that let declarations do not move to the top of the current execution context.","title":"var &amp; let"},{"location":"js_ECMAScript6/#const","text":"const variables have the same scope as variables declared using let. The difference is that const variables are immutable - they are not allowed to be reassigned. For example, the following generates an exception: const x = 5 ; x = 6 ; const is not subject to Variable Hoisting too, which means that const declarations do not move to the top of the current execution context. Also note that ES6 code will run only in browsers that support it. Older devices and browsers that do not support ES6 will return a syntax error.","title":"const"},{"location":"js_ECMAScript6/#template-literals-in-es6","text":"Template literals are a way to output variables in the string. Prior to ES6 we had to break the string, for example: var name = 'John' ; var text = 'My name is ' + name ; Now we can use template literals: var name = 'John' ; var text = `My name is ${ name } ` ; Notice that template literals are enclosed by the backtick ( ) character instead of double or single quotes. The ${expression} is a placeholder, and can include any expression, which will get evaluated and inserted into the template literal. let a = 8 ; let b = 3 ; let msg = `The sum is ${ a + b } !` ; console . log ( msg ); To escape a backtick in a template literal, put a backslash \\ before the backtick.","title":"Template Literals in ES6"},{"location":"js_ECMAScript6/#loops","text":"In JavaScript we commonly use the for loop to iterate over values in a list: let arr = [ 1 , 2 , 3 ]; for ( let k = 0 ; k < arr . length ; k ++ ){ console . log ( arr [ k ]); }","title":"Loops"},{"location":"js_ECMAScript6/#forin-loop","text":"The for...in loop is intended for iterating over the enumerable keys of an object. For example: let obj = { a : 1 , b : 2 , c : 3 }; for ( let v in obj ){ console . log ( v ); } The for...in loop should NOT be used to iterate over arrays because, depending on the JavaScript engine, it could iterate in an arbitrary order. Also, the iterating variable is a string, not a number, so if you try to do any math with the variable, you'll be performing string concatenation instead of addition.","title":"For..in loop"},{"location":"js_ECMAScript6/#forof-loop","text":"ES6 introduces the new for...of loop, which creates a loop iterating over iterable objects. For example: let list = [ \"x\" , \"y\" , \"z\" ]; for ( let val of list ){ console . log ( val ); } During each iteration the val variable is assigned the corresponding element in the list. The for...of loop works for other iterable objects as well, including strings for ( let val of \"Hello\" ){ console . log ( val ); } The for...of loop also works on the newly introduced collections (Map, Set, WeakMap, and WeakSet).","title":"For...of loop"},{"location":"js_ECMAScript6/#functions-in-ecmascript-6","text":"Prior to ES6, a JavaScript function was defined like this: function add ( x , y ){ var sum = x + y ; console . log ( sum ); } ES6 introduces a new syntax for writing functions. The same function from above can be written as: const add = ( x , y ) => { let sum = x + y ; console . log ( sum ); } This new syntax is quite handy when you just need a simple function with one argument. You can skip typing function and return, as well as some parentheses and braces. For example: const greet = x => \"Welcome \" + x ; console . log ( greet ( \"John\" )); The code above defines a function named greet that has one argument and returns a message. If there are no parameters, an empty pair of parentheses should be used, as in const x = () => alert ( \"Hi\" ); The syntax is very useful for inline functions. For example, let's say we have an array, and for each element of the array we need to execute a function. We use the forEach method of the array to call a function for each element: var arr = [ 2 , 3 , 7 , 8 ]; arr . forEach ( function ( el ) { console . log ( el * 2 ); }); However, in ES6, the code above can be rewritten as following: var arr = [ 2 , 3 , 7 , 8 ]; arr . forEach ( v => { console . log ( v * 2 ); });","title":"Functions in ECMAScript 6"},{"location":"js_ECMAScript6/#default-parameters-in-es6","text":"In ES6, we can put the default values right in the signature of the functions. function test ( a , b = 3 , c = 42 ){ return a + b + c ; } console . log ( test ( 5 )); //50 And here's an example of an arrow function with default parameters: const test = ( a , b = 3 , c = 42 ) => { return a + b + c ; } console . log ( test ( 5 )); //50 Default value expressions are evaluated at function call time from left to right. This also means that default expressions can use the values of previously-filled parameters.","title":"Default Parameters in ES6"},{"location":"js_ECMAScript6/#es6-objects","text":"JavaScript variables can be Object data types that contain many values called properties. An object can also have properties that are function definitions called methods for performing actions on the object. ES6 introduces shorthand notations and computed property names that make declaring and using objects easier to understand. The new method definition shorthand does not require the colon (:) or function keyword, as in the grow function of the tree object declaration: let tree = { height : 10 , color : 'green' , grow () { this . height += 2 ; } }; tree . grow (); console . log ( tree . height ); //12 You can also use a property value shorthand when initializing properties with a variable by the same name. For example, properties height and health are being initialized with variables named height and health let height = 5 ; let health = 100 ; let athlete = { height , health }; console . log ( athlete . height ); //5 console . log ( athlete . health ); //100 When creating an object by using duplicate property names, the last property will overwrite the prior ones of the same name. For Example: var a = { x : 1 , x : 2 , x : 3 , x : 4 }; console . log ( a . x ); //4 Duplicate property names generated a SyntaxError in ES5 when using strict mode. However, ES6 removed this limitation.","title":"ES6 Objects"},{"location":"js_ECMAScript6/#computed-property-names","text":"With ES6, you can now use computed property names. Using the square bracket notation [], we can use an expression for a property name, including concatenating strings. This can be useful in cases where we want to create certain objects based on user data (e.g. id, email, and so on). It is very useful when you need to create custom objects based on some variables. Here are three examples: Example 1 let prop = 'name' ; let id = '1234' ; let mobile = '12345678' ; let user = { [ prop ] : 'Jack' , [ `user_ ${ id } ` ] : ` ${ mobile } ` }; Example 2 var i = 0 ; var a = { [ 'foo' + ++ i ] : i , [ 'foo' + ++ i ] : i , [ 'foo' + ++ i ] : i }; Example 3 var param = 'size' ; var config = { [ param ] : 12 , [ 'mobile' + param . charAt ( 0 ). toUpperCase () + param . slice ( 1 )] : 4 }; console . log ( config . mobileSize );","title":"Computed Property Names"},{"location":"js_ECMAScript6/#objectassign-in-es6","text":"ES6 adds a new Object method assign() that allows us to combine multiple sources into one target to create a single new object. Object.assign() is also useful for creating a duplicate of an existing object. Let's look at the following example to see how to combine objects: let person = { name : 'Jack' , age : 18 , sex : 'male' }; let student = { name : 'Bob' , age : 20 , xp : '2' }; let student = Object . assign ({}, person , student ); Here we used Object.assign() where the first parameter is the target object you want to apply new properties to. Every parameter after the first will be used as sources for the target. There are no limitations on the number of source parameters. However, order is important because properties in the second parameter will be overridden by properties of the same name in third parameter, and so on. In the example above, we used a new object {} as the target and used two objects as sources. Now, let's see how we can use assign() to create a duplicate object without creating a reference (mutating) to the base object. In the following example, assignment was used to try to generate a new object. However, using = creates a reference to the base object. Because of this reference, changes intended for a new object mutate the original object: let person = { name : 'Jack' , age : 18 }; let newPerson = person ; //newPerson references person newPerson . name = 'Bob' ; console . log ( person . name ); //Bob console . log ( newPerson . name ); //Bob To avoid this (mutations), use Object.assign() to create a new object. For example: let person = { name : 'Jack' , age : 18 }; let newPerson = Object . assign ({}, person ); newPerson . name = 'Bob' ; console . log ( person . name ); //Jack console . log ( newPerson . name ); //Bob Finally, you can assign a value to an object property in the Object.assign() statement. For example: let person = { name : 'Jack' , age : 18 }; let newPerson = Object . assign ({}, person , { name : 'Bob' }); console . log ( person . name ); //Jack console . log ( newPerson . name ); //Bob","title":"Object.assign() in ES6"},{"location":"js_ECMAScript6/#array-destructuring-in-es6","text":"The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables. ES6 has added a shorthand syntax for destructuring an array. The following example demonstrates how to unpack the elements of an array into distinct variables: let arr = [ '1' , '2' , '3' ]; let [ one , two , three ] = arr ; console . log ( one ); //1 console . log ( two ); //2 console . log ( three ); //3 We can also destructure an array returned by a function. let a = () => { return [ 1 , 2 , 3 ]; }; let [ one ,, two ] = a (); console . log ( one ); //1 console . log ( two ); //3 Notice that we left the second argument's place empty. The destructuring syntax also simplifies assignment and swapping values: let a , b , c = 4 , d = 8 ; [ a , b = 6 ] = [ 2 ]; // a=2, b=6 [ c , d ] = [ d , c ]; // c=8, d = 4 console . log ( a ); //2 console . log ( b ); //6 console . log ( c ); //4 console . log ( d ); //8","title":"Array Destructuring in ES6"},{"location":"js_ECMAScript6/#object-destructuring-in-es6","text":"Similar to Array destructuring, Object destructuring unpacks properties into distinct variables. For example: let obj = { h : 100 , s : true }; let { h , s } = obj ; console . log ( h ); //100 console . log ( s ); //true We can assign without declaration, but there are some syntax requirements for that: For example: let a , b ; ({ a , b } = { a : 'Hello' , b : 'world!' }); console . log ( a ); //Hello console . log ( b ); //world! The () with a semicolon (;) at the end are mandatory when destructuring without a declaration. However, you can also do it as follows where the () are not required: let { a , b } = { a : 'Hello' , b : 'world!' }; console . log ( a ); //Hello console . log ( b ); //world! You can also assign the object to new variable names. For example: var o = { h : 42 , s : true }; var { h : foo , s : bar } = o ; //console.log(h); //Error console . log ( foo ); //42 console . log ( bar ); //true Finally you can assign default values to variables, in case the value unpacked from the object is undefined. For example: var obj = { id : 42 , name : 'Carlos' }; let { id = 10 , age = 20 } = obj ; console . log ( id ); //42 console . log ( age ); //20","title":"Object Destructuring in ES6"},{"location":"js_ECMAScript6/#es6-rest-parameters","text":"","title":"ES6 Rest Parameters"},{"location":"js_dom/","text":"The DOM When you open any webpage in a browser, the HTML of the page is loaded and rendered visually on the screen. To accomplish that, the browser builds the Document Object Model of that page, which is an object oriented model of its logical structure. JavaScript can be used to manipulate the DOM of a page dynamically to add, delete and modify elements. The DOM represents a document as a tree structure. HTML elements become interrelated nodes in the tree. All those nodes in the tree have some kind of relations among each other. Nodes can have child nodes. Nodes on the same tree level are called siblings. For the example above: < html > has two children ( < head > , < body > ); < head > has one child ( < title > ) and one parent ( < html > ); < title > has one parent ( < head > ) and no children; < body > has two children ( < h1 > and < a > ) and one parent ( < html > ); It is important to understand the relationships between elements in an HTML document in order to be able to manipulate them with JavaScript. The document Object There is a predefined document object in JavaScript, which can be used to access all elements on the DOM. In other words, the document object is the owner (or root) of all objects in your webpage. So, if you want to access objects in an HTML page, you always start with accessing the document object. For example: document . body . innerHTML = \"Some text\" ; As body is an element of the DOM, we can access it using the document object and change the content of the innerHTML property. The innerHTML property can be used on almost all HTML elements to change its content. Selecting Elements All HTML elements are objects. And as we know every object has properties and methods. The document object has methods that allow you to select the desired HTML element. These three methods are the most commonly used for selecting HTML elements: //finds element by id document . getElementById ( id ) //finds elements by class name document . getElementsByClassName ( name ) //finds elements by tag name document . getElementsByTagName ( name ) In the example below, the getElementById method is used to select the element with id=\"demo\" and change its content: var elem = document . getElementById ( \"demo\" ); elem . innerHTML = \"Hello World!\" ; The example above assumes that the HTML contains an element with id=\"demo\", for example <div id=\"demo\"></div>. The getElementsByClassName() method returns a collection of all elements in the document with the specified class name. For example, if our HTML page contained three elements with class=\"demo\", the following code would return all those elements as an array: var arr = document . getElementsByClassName ( \"demo\" ); //accessing the second element arr [ 1 ]. innerHTML = \"Hi\" ; Similarly, the getElementsByTagName method returns all of the elements of the specified tag name as an array. The following example gets all paragraph elements of the page and changes their content: < p > hi < /p> < p > hello < /p> < p > hi < /p> < script > var arr = document . getElementsByTagName ( \"p\" ); for ( var x = 0 ; x < arr . length ; x ++ ) { arr [ x ]. innerHTML = \"Hi there\" ; } < /script> The script will result in the following HTML: < p > Hi there < /p> < p > Hi there < /p> < p > Hi there < /p> We used the length property of the array to loop through all the selected elements in the above example. Working with DOM Each element in the DOM has a set of properties and methods that provide information about their relationships in the DOM: element.childNodes returns an array of an element's child nodes. element.firstChild returns the first child node of an element. element.lastChild returns the last child node of an element. element.hasChildNodes returns true if an element has any child nodes, otherwise false. element.nextSibling returns the next node at the same tree level. element.previousSibling returns the previous node at the same tree level. element.parentNode returns the parent node of an element. We can, for example, select all child nodes of an element and change their content: < html > < body > < div id = \"demo\" > hi < p > hi </ p > < p > hello </ p > </ div > < script > var a = document . getElementsById ( \"demo\" ); var arr = a . childNodes ; for ( var x = 0 ; x < arr . length ; x ++ ) { arr [ x ]. innerHTML = \"Hi there\" ; } </ script > </ body > </ html > Changing Elements Once you have selected the element(s) you want to work with, you can change their attributes. As we have seen in the previous lessons, we can change the text content of an element using the innerHTML property. Similarly, we can change the attributes of elements. For example, we can change the src attribute of an image: < img id = \"myimg\" src = \"orange.png\" alt = \"\" /> < script > var el = document . getElementById ( \"myimg\" ); el . src = \"apple.png\" ; </ script > We can change the href attribute of a link: < a href = \"http://www.google.com/\" > Some URL </ a > < script > var el = document . getElementByTagName ( \"a\" ); el [ 0 ]. href = \"http://myurl.com/\" ; </ script > The style of HTML elements can also be changed using JavaScript. All style attributes can be accessed using the style object of the element. All CSS properties can be set and modified using JavaScript. Just remember, that you cannot use dashes (-) in the property names: these are replaced with camelCase versions, where the compound words begin with a capital letter. For example: the background-color property should be referred to as backgroundColor. < div id = \"demo\" style = \"width:200px\" > Some text </ div > < script > var el = document . getElementById ( \"demo\" ); el . style . color = \"6600FF\" ; el . style . width = \"100px\" ; </ script > Creating Elements Use the following methods to create new nodes: element.cloneNode() clones an element and returns the resulting node. document.createElement(element) creates a new element node. document.createTextNode(text) creates a new text node. var node = document.createTextNode(\"Some new text\"); This will create a new text node, but it will not appear in the document until you append it to an existing element with one of the following methods: element.appendChild(newNode) adds a new child node to an element as the last child node. element.insertBefore(node1, node2) inserts node1 as a child before node2. < div id = \"demo\" > Some Text </ div > < script > //create a new paragraph var p = document . createElement ( \"p\" ); var node = document . createTextNode ( \"Some new text\" ); //adding the text to paragraph p . appendChild ( node ); var div = document . getElementById ( \"demo\" ); //adding the paragraph to the div div . appendChild ( p ); </ script > To remove an HTML element, you must select the parent of the element and use the removeChild(node) method. An alternative way of achieving the same result would be the use of the parentNode property to get the parent of the element we want to remove: var child = document.getElementById(\"p1\"); child.parentNode.removeChild(child); To replace an HTML element, the element.replaceChild(newNode, oldNode) method is used. Animations To create an animation, we need to change the properties of an element at small intervals of time. We can achieve this by using the setInterval() method, which allows us to create a timer and call a function to change properties repeatedly at defined intervals (in milliseconds). For example: var t = setInterval ( move , 500 ); This code creates a timer that calls a move() function every 500 milliseconds. Now we need to define the move() function, that changes the position of the box. // starting position var pos = 0 ; //our box element var box = document . getElementById ( \"box\" ); function move () { pos += 1 ; box . style . left = pos + \"px\" ; //px = pixels } The move() function increments the left property of the box element by one each time it is called. The following code defines a timer that calls the move() function every 10 milliseconds: var t = setInterval ( move , 10 ); However, this makes our box move to the right forever. To stop the animation when the box reaches the end of the container, we add a simple check to the move() function and use the clearInterval() method to stop the timer. function move () { if ( pos >= 150 ) { clearInterval ( t ); } else { pos += 1 ; box . style . left = pos + \"px\" ; } } When the left attribute of the box reaches the value of 150, the box reaches the end of the container, based on a container width of 200 and a box width of 50.","title":"DOM"},{"location":"js_dom/#the-dom","text":"When you open any webpage in a browser, the HTML of the page is loaded and rendered visually on the screen. To accomplish that, the browser builds the Document Object Model of that page, which is an object oriented model of its logical structure. JavaScript can be used to manipulate the DOM of a page dynamically to add, delete and modify elements. The DOM represents a document as a tree structure. HTML elements become interrelated nodes in the tree. All those nodes in the tree have some kind of relations among each other. Nodes can have child nodes. Nodes on the same tree level are called siblings. For the example above: < html > has two children ( < head > , < body > ); < head > has one child ( < title > ) and one parent ( < html > ); < title > has one parent ( < head > ) and no children; < body > has two children ( < h1 > and < a > ) and one parent ( < html > ); It is important to understand the relationships between elements in an HTML document in order to be able to manipulate them with JavaScript.","title":"The DOM"},{"location":"js_dom/#the-document-object","text":"There is a predefined document object in JavaScript, which can be used to access all elements on the DOM. In other words, the document object is the owner (or root) of all objects in your webpage. So, if you want to access objects in an HTML page, you always start with accessing the document object. For example: document . body . innerHTML = \"Some text\" ; As body is an element of the DOM, we can access it using the document object and change the content of the innerHTML property. The innerHTML property can be used on almost all HTML elements to change its content.","title":"The document Object"},{"location":"js_dom/#selecting-elements","text":"All HTML elements are objects. And as we know every object has properties and methods. The document object has methods that allow you to select the desired HTML element. These three methods are the most commonly used for selecting HTML elements: //finds element by id document . getElementById ( id ) //finds elements by class name document . getElementsByClassName ( name ) //finds elements by tag name document . getElementsByTagName ( name ) In the example below, the getElementById method is used to select the element with id=\"demo\" and change its content: var elem = document . getElementById ( \"demo\" ); elem . innerHTML = \"Hello World!\" ; The example above assumes that the HTML contains an element with id=\"demo\", for example <div id=\"demo\"></div>. The getElementsByClassName() method returns a collection of all elements in the document with the specified class name. For example, if our HTML page contained three elements with class=\"demo\", the following code would return all those elements as an array: var arr = document . getElementsByClassName ( \"demo\" ); //accessing the second element arr [ 1 ]. innerHTML = \"Hi\" ; Similarly, the getElementsByTagName method returns all of the elements of the specified tag name as an array. The following example gets all paragraph elements of the page and changes their content: < p > hi < /p> < p > hello < /p> < p > hi < /p> < script > var arr = document . getElementsByTagName ( \"p\" ); for ( var x = 0 ; x < arr . length ; x ++ ) { arr [ x ]. innerHTML = \"Hi there\" ; } < /script> The script will result in the following HTML: < p > Hi there < /p> < p > Hi there < /p> < p > Hi there < /p> We used the length property of the array to loop through all the selected elements in the above example.","title":"Selecting Elements"},{"location":"js_dom/#working-with-dom","text":"Each element in the DOM has a set of properties and methods that provide information about their relationships in the DOM: element.childNodes returns an array of an element's child nodes. element.firstChild returns the first child node of an element. element.lastChild returns the last child node of an element. element.hasChildNodes returns true if an element has any child nodes, otherwise false. element.nextSibling returns the next node at the same tree level. element.previousSibling returns the previous node at the same tree level. element.parentNode returns the parent node of an element. We can, for example, select all child nodes of an element and change their content: < html > < body > < div id = \"demo\" > hi < p > hi </ p > < p > hello </ p > </ div > < script > var a = document . getElementsById ( \"demo\" ); var arr = a . childNodes ; for ( var x = 0 ; x < arr . length ; x ++ ) { arr [ x ]. innerHTML = \"Hi there\" ; } </ script > </ body > </ html >","title":"Working with DOM"},{"location":"js_dom/#changing-elements","text":"Once you have selected the element(s) you want to work with, you can change their attributes. As we have seen in the previous lessons, we can change the text content of an element using the innerHTML property. Similarly, we can change the attributes of elements. For example, we can change the src attribute of an image: < img id = \"myimg\" src = \"orange.png\" alt = \"\" /> < script > var el = document . getElementById ( \"myimg\" ); el . src = \"apple.png\" ; </ script > We can change the href attribute of a link: < a href = \"http://www.google.com/\" > Some URL </ a > < script > var el = document . getElementByTagName ( \"a\" ); el [ 0 ]. href = \"http://myurl.com/\" ; </ script > The style of HTML elements can also be changed using JavaScript. All style attributes can be accessed using the style object of the element. All CSS properties can be set and modified using JavaScript. Just remember, that you cannot use dashes (-) in the property names: these are replaced with camelCase versions, where the compound words begin with a capital letter. For example: the background-color property should be referred to as backgroundColor. < div id = \"demo\" style = \"width:200px\" > Some text </ div > < script > var el = document . getElementById ( \"demo\" ); el . style . color = \"6600FF\" ; el . style . width = \"100px\" ; </ script >","title":"Changing Elements"},{"location":"js_dom/#creating-elements","text":"Use the following methods to create new nodes: element.cloneNode() clones an element and returns the resulting node. document.createElement(element) creates a new element node. document.createTextNode(text) creates a new text node. var node = document.createTextNode(\"Some new text\"); This will create a new text node, but it will not appear in the document until you append it to an existing element with one of the following methods: element.appendChild(newNode) adds a new child node to an element as the last child node. element.insertBefore(node1, node2) inserts node1 as a child before node2. < div id = \"demo\" > Some Text </ div > < script > //create a new paragraph var p = document . createElement ( \"p\" ); var node = document . createTextNode ( \"Some new text\" ); //adding the text to paragraph p . appendChild ( node ); var div = document . getElementById ( \"demo\" ); //adding the paragraph to the div div . appendChild ( p ); </ script > To remove an HTML element, you must select the parent of the element and use the removeChild(node) method. An alternative way of achieving the same result would be the use of the parentNode property to get the parent of the element we want to remove: var child = document.getElementById(\"p1\"); child.parentNode.removeChild(child); To replace an HTML element, the element.replaceChild(newNode, oldNode) method is used.","title":"Creating Elements"},{"location":"js_dom/#animations","text":"To create an animation, we need to change the properties of an element at small intervals of time. We can achieve this by using the setInterval() method, which allows us to create a timer and call a function to change properties repeatedly at defined intervals (in milliseconds). For example: var t = setInterval ( move , 500 ); This code creates a timer that calls a move() function every 500 milliseconds. Now we need to define the move() function, that changes the position of the box. // starting position var pos = 0 ; //our box element var box = document . getElementById ( \"box\" ); function move () { pos += 1 ; box . style . left = pos + \"px\" ; //px = pixels } The move() function increments the left property of the box element by one each time it is called. The following code defines a timer that calls the move() function every 10 milliseconds: var t = setInterval ( move , 10 ); However, this makes our box move to the right forever. To stop the animation when the box reaches the end of the container, we add a simple check to the move() function and use the clearInterval() method to stop the timer. function move () { if ( pos >= 150 ) { clearInterval ( t ); } else { pos += 1 ; box . style . left = pos + \"px\" ; } } When the left attribute of the box reaches the value of 150, the box reaches the end of the container, based on a container width of 200 and a box width of 50.","title":"Animations"},{"location":"js_event/","text":"Events You can write JavaScript code that executes when an event occurs, such as when a user clicks an HTML element, moves the mouse, or submits a form. When an event occurs on a target element, a handler function is executed. Common HTML events: Event Description onchange An HTML element has been changed onclick The user clicks an HTML element onmouseover The user moves the mouse over an HTML element onmouseout The user moves the mouse away from an HTML element onkeydown The user pushes a keyboard key onload The browser has finished loading the page Corresponding events can be added to HTML elements as attributes. For example: < p onclick = \"someFunc()\" > some text </ p > Handling Events Let's display an alert popup when the user clicks a specified button: < button onclick = \"show()\" > Click Me </ button > < script > function show (){ alert ( \"hello\" ); } </ script > Event handlers can be assigned to elements. For example: var x=document.getElementById(\"demo\"); x.onclick = function () { document.body.innerHTML = Date(); } The onload and onunload events are triggered when the user enters or leaves the page. These can be useful when performing actions after the page is loaded. < body onload = \"doSomething()\" > Similarly, the window.onload event can be used to run code after the whole page is loaded. window . onload \u200b = function () { \u200b //some code } The onchange event is mostly used on textboxes. The event handler gets called when the text inside the textbox changes and focus is lost from the element. Event Listeners The addEventListener() method attaches an event handler to an element without overwriting existing event handlers. You can add many event handlers to one element. You can also add many event handlers of the same type to one element, i.e., two \"click\" events. element . addEventListener ( event , function , useCapture ); The first parameter is the event's type (like \"click\" or \"mousedown\"). The second parameter is the function we want to call when the event occurs. The third parameter is a Boolean value specifying whether to use event bubbling or event capturing. This parameter is optional, and will be described in the next lesson. Note that you don't use the \"on\" prefix for this event; use \"click\" instead of \"onclick\". Example: element . addEventListener ( \"click\" , myFunction ); element . addEventListener ( \"mouseover\" , myFunction ); function myFunction () { alert ( \"Hello World!\" ); } This adds two event listeners to the element. We can remove one of the listeners: element . removeEventListener ( \"mouseover\" , myFunction ); Internet Explorer version 8 and lower do not support the addEventListener() and removeEventListener() methods. However, you can use the document.attachEvent() method to attach event handlers in Internet Explorer. Event Propagation There are two ways of event propagation in the HTML DOM: bubbling and capturing. Event propagation allows for the definition of the element order when an event occurs. If you have a <p> element inside a <div> element, and the user clicks on the <p> element, which element's \"click\" event should be handled first? In bubbling, the innermost element's event is handled first and then the outer element's event is handled. The <p> element's click event is handled first, followed by the <div> element's click event. In capturing, the outermost element's event is handled first and then the inner. The <div> element's click event is handled first, followed by the <p> element's click event. Capturing goes down the DOM. Bubbling goes up the DOM. Capturing vs. Bubbling The addEventListener() method allows you to specify the propagation type with the \"useCapture\" parameter. addEventListener ( event , function , useCapture ) The default value is false, which means the bubbling propagation is used; when the value is set to true, the event uses the capturing propagation. //Capturing propagation elem1 . addEventListener ( \"click\" , myFunction , true ); //Bubbling propagation elem2 . addEventListener ( \"click\" , myFunction , false ); This is particularly useful when you have the same event handled for multiple elements in the DOM hierarchy. Image Slider - Example Now we need to handle the Next and Prev button clicks and call the corresponding functions to change the image. js HTML: < div > < button onclick = \"prev()\" > Prev </ button > < img id = \"slider\" src = \"http://www.mysite.com/uploads/slider/1.jpg\" width = \"200px\" height = \"100px\" /> < button onclick = \"next()\" > Next </ button > </ div > //JS: var images = [ \"http://www.mysite.com/uploads/slider/1.jpg\" , \"http://www.mysite.com/uploads/slider/2.jpg\" , \"http://www.mysite.com/uploads/slider/3.jpg\" ]; var num = 0 ; function next () { var slider = document . getElementById ( \"slider\" ); num ++ ; if ( num >= images . length ){ num = 0 ; } slider . src = images [ num ]; } function prev (){ var slider = document . getElementById ( \"slider\" ); num -- ; if ( num < 0 ){ num = images . length - 1 ; } slider . src = images [ num ]; } Form Validation HTML5 adds some attributes that allow form validation. For example, the required attribute can be added to an input field to make it mandatory to fill in. More complex form validation can be done using JavaScript. The form element has an onsubmit event that can be handled to perform validation. For example, let's create a form with two inputs and one button. The text in both fields should be the same and not blank to pass the validation. < form onsubmit = \"return validate()\" method = \"post\" > Number: < input type = \"text\" name = \"num1\" id = \"num1\" /> < br /> Repeat: < input type = \"text\" name = \"num2\" id = \"num2\" /> < br /> < input type = \"submit\" value = \"Submit\" /> </ form > function validate () { var n1 = document . getElementById ( \"num1\" ); var n2 = document . getElementById ( \"num2\" ); if ( n1 . value != \"\" && n2 . value != \"\" ){ if ( n1 . value == n2 . value ){ return true ; } } alert ( \"The values should be equal and not blank\" ); return false ; } The form will not get submitted if its onsubmit event returns false","title":"Events"},{"location":"js_event/#events","text":"You can write JavaScript code that executes when an event occurs, such as when a user clicks an HTML element, moves the mouse, or submits a form. When an event occurs on a target element, a handler function is executed. Common HTML events: Event Description onchange An HTML element has been changed onclick The user clicks an HTML element onmouseover The user moves the mouse over an HTML element onmouseout The user moves the mouse away from an HTML element onkeydown The user pushes a keyboard key onload The browser has finished loading the page Corresponding events can be added to HTML elements as attributes. For example: < p onclick = \"someFunc()\" > some text </ p >","title":"Events"},{"location":"js_event/#handling-events","text":"Let's display an alert popup when the user clicks a specified button: < button onclick = \"show()\" > Click Me </ button > < script > function show (){ alert ( \"hello\" ); } </ script > Event handlers can be assigned to elements. For example: var x=document.getElementById(\"demo\"); x.onclick = function () { document.body.innerHTML = Date(); } The onload and onunload events are triggered when the user enters or leaves the page. These can be useful when performing actions after the page is loaded. < body onload = \"doSomething()\" > Similarly, the window.onload event can be used to run code after the whole page is loaded. window . onload \u200b = function () { \u200b //some code } The onchange event is mostly used on textboxes. The event handler gets called when the text inside the textbox changes and focus is lost from the element.","title":"Handling Events"},{"location":"js_event/#event-listeners","text":"The addEventListener() method attaches an event handler to an element without overwriting existing event handlers. You can add many event handlers to one element. You can also add many event handlers of the same type to one element, i.e., two \"click\" events. element . addEventListener ( event , function , useCapture ); The first parameter is the event's type (like \"click\" or \"mousedown\"). The second parameter is the function we want to call when the event occurs. The third parameter is a Boolean value specifying whether to use event bubbling or event capturing. This parameter is optional, and will be described in the next lesson. Note that you don't use the \"on\" prefix for this event; use \"click\" instead of \"onclick\". Example: element . addEventListener ( \"click\" , myFunction ); element . addEventListener ( \"mouseover\" , myFunction ); function myFunction () { alert ( \"Hello World!\" ); } This adds two event listeners to the element. We can remove one of the listeners: element . removeEventListener ( \"mouseover\" , myFunction ); Internet Explorer version 8 and lower do not support the addEventListener() and removeEventListener() methods. However, you can use the document.attachEvent() method to attach event handlers in Internet Explorer.","title":"Event Listeners"},{"location":"js_event/#event-propagation","text":"There are two ways of event propagation in the HTML DOM: bubbling and capturing. Event propagation allows for the definition of the element order when an event occurs. If you have a <p> element inside a <div> element, and the user clicks on the <p> element, which element's \"click\" event should be handled first? In bubbling, the innermost element's event is handled first and then the outer element's event is handled. The <p> element's click event is handled first, followed by the <div> element's click event. In capturing, the outermost element's event is handled first and then the inner. The <div> element's click event is handled first, followed by the <p> element's click event. Capturing goes down the DOM. Bubbling goes up the DOM.","title":"Event Propagation"},{"location":"js_event/#capturing-vs-bubbling","text":"The addEventListener() method allows you to specify the propagation type with the \"useCapture\" parameter. addEventListener ( event , function , useCapture ) The default value is false, which means the bubbling propagation is used; when the value is set to true, the event uses the capturing propagation. //Capturing propagation elem1 . addEventListener ( \"click\" , myFunction , true ); //Bubbling propagation elem2 . addEventListener ( \"click\" , myFunction , false ); This is particularly useful when you have the same event handled for multiple elements in the DOM hierarchy.","title":"Capturing vs. Bubbling"},{"location":"js_event/#image-slider-example","text":"Now we need to handle the Next and Prev button clicks and call the corresponding functions to change the image. js HTML: < div > < button onclick = \"prev()\" > Prev </ button > < img id = \"slider\" src = \"http://www.mysite.com/uploads/slider/1.jpg\" width = \"200px\" height = \"100px\" /> < button onclick = \"next()\" > Next </ button > </ div > //JS: var images = [ \"http://www.mysite.com/uploads/slider/1.jpg\" , \"http://www.mysite.com/uploads/slider/2.jpg\" , \"http://www.mysite.com/uploads/slider/3.jpg\" ]; var num = 0 ; function next () { var slider = document . getElementById ( \"slider\" ); num ++ ; if ( num >= images . length ){ num = 0 ; } slider . src = images [ num ]; } function prev (){ var slider = document . getElementById ( \"slider\" ); num -- ; if ( num < 0 ){ num = images . length - 1 ; } slider . src = images [ num ]; }","title":"Image Slider - Example"},{"location":"js_event/#form-validation","text":"HTML5 adds some attributes that allow form validation. For example, the required attribute can be added to an input field to make it mandatory to fill in. More complex form validation can be done using JavaScript. The form element has an onsubmit event that can be handled to perform validation. For example, let's create a form with two inputs and one button. The text in both fields should be the same and not blank to pass the validation. < form onsubmit = \"return validate()\" method = \"post\" > Number: < input type = \"text\" name = \"num1\" id = \"num1\" /> < br /> Repeat: < input type = \"text\" name = \"num2\" id = \"num2\" /> < br /> < input type = \"submit\" value = \"Submit\" /> </ form > function validate () { var n1 = document . getElementById ( \"num1\" ); var n2 = document . getElementById ( \"num2\" ); if ( n1 . value != \"\" && n2 . value != \"\" ){ if ( n1 . value == n2 . value ){ return true ; } } alert ( \"The values should be equal and not blank\" ); return false ; } The form will not get submitted if its onsubmit event returns false","title":"Form Validation"},{"location":"js_func/","text":"JavaScript Functions Functions define behavior. A function is a collection of statements that are grouped together to perform an operation. You can define your own functions to perform your desired tasks. Functions have many advantages, including: Reusable code. Easy to test. Modifications to a function do not affect the calling program. One function can accept many different inputs. To define a JavaScript function, use the function keyword, followed by a name, followed by a set of parentheses (). The code to be executed by the function is placed inside curly brackets {}. function name () { //code to be executed } Function names can contain letters, digits, underscores, and dollar signs (same rules as variables). Parameters should be given names, which are separated by commas within the parentheses. If you pass more arguments than are defined, they will be assigned to an array called arguments. They can be used like this: arguments[0], arguments[1], etc. After defining the function, you can call it as many times as needed. JavaScript functions do not check the number of arguments received. If a function is called with missing arguments (fewer than declared), the missing values are set to undefined, which indicates that a variable has not been assigned a value. //Function definition function sayHello ( name , age ) { console . log ( name + \" is \" + age + \" years old.\" ); } //Function use sayHello ( \"Cassie\" , 20 ); A function can have an optional return statement. It is used to return a value from the function. This statement is useful when making calculations that require a result. When JavaScript reaches a return statement, the function stops executing. //Function definition function myFunction ( a , b ) { return a * b ; } //Function use var res = myFunction ( 3 , 2 ); If you do not return anything from a function, it will return undefined. JavaScript Objects JavaScript variables are containers for data values. Objects are variables too, but they can contain many values. Think of an object as a list of values that are written as name:value pairs, with the names and the values separated by colons. You can access object properties in two ways. objectName . propertyName //or objectName [ 'propertyName' ] var person = { name : \"John\" , age : 31 , favColor : \"green\" , height : 183 }; var x = person . age ; //the same as: var y = person [ 'age' ]; These values are called properties. JavaScript objects are containers for named values. JavaScript's built-in length property is used to count the number of characters in a property or string. An object method is a property that contains a function definition. Use the following syntax to access an object method. objectName . methodName () Methods are functions that are stored as object properties. Constructor Function Sometimes, we need to set an \"object type\" that can be used to create a number of objects of a single type. The standard way to create an \"object type\" is to use an object constructor function. function person ( name , age , color ) { this . name = name ; this . age = age ; this . favColor = color ; } The above function (person) is an object constructor, which takes parameters and assigns them to the object properties. The this keyword refers to the current object. Note that this is not a variable. It is a keyword, and its value cannot be changed. Once you have an object constructor, you can use the new keyword to create new objects of the same type. var p1 = new person ( \"Amid\" , 42 , \"purple\" ); var p2 = new person ( \"Jessie\" , 39 , \"red\" ); p1 and p2 are now objects of the person type. Their properties are assigned to the corresponding values. Object Initialization Use the object literal or initializer syntax to create single objects. var John = { name : \"John\" , age : 25 }; var James = { name : \"James\" , age : 21 }; Objects consist of properties, which are used to describe an object. Values of object properties can either contain primitive data types or other objects. Object Methods Methods are functions that are stored as object properties. Use the following syntax to create an object method: methodName = function () { code lines } Access an object method using the following syntax: objectName . methodName () A method is a function, belonging to an object. It can be referenced using the this keyword. The this keyword is used as a reference to the current object, meaning that you can access the objects properties and methods using it. Defining methods is done inside the constructor function. function person ( name , age , color ) { this . name = name ; this . age = age ; this . changeName = function ( name ){ this . name = name ; } } var p = new person ( \"David\" , 21 ); p . changeName ( \"Jhon\" ); You can also define the function outside of the constructor function and associate it with the object. function person ( name , age ) { this . name = name ; this . age = age ; this . yearOfBirth = bornYear ; } function bornYear () { return 2016 - this . age ; } var p = new person ( \"David\" , 21 ); console . log ( p . yearOfBirth ()); Note that it's not necessary to write the function's parentheses when assigning it to an object. Call the method by the property name you specified in the constructor function, rather than the function name.","title":"Functions"},{"location":"js_func/#javascript-functions","text":"Functions define behavior. A function is a collection of statements that are grouped together to perform an operation. You can define your own functions to perform your desired tasks. Functions have many advantages, including: Reusable code. Easy to test. Modifications to a function do not affect the calling program. One function can accept many different inputs. To define a JavaScript function, use the function keyword, followed by a name, followed by a set of parentheses (). The code to be executed by the function is placed inside curly brackets {}. function name () { //code to be executed } Function names can contain letters, digits, underscores, and dollar signs (same rules as variables). Parameters should be given names, which are separated by commas within the parentheses. If you pass more arguments than are defined, they will be assigned to an array called arguments. They can be used like this: arguments[0], arguments[1], etc. After defining the function, you can call it as many times as needed. JavaScript functions do not check the number of arguments received. If a function is called with missing arguments (fewer than declared), the missing values are set to undefined, which indicates that a variable has not been assigned a value. //Function definition function sayHello ( name , age ) { console . log ( name + \" is \" + age + \" years old.\" ); } //Function use sayHello ( \"Cassie\" , 20 ); A function can have an optional return statement. It is used to return a value from the function. This statement is useful when making calculations that require a result. When JavaScript reaches a return statement, the function stops executing. //Function definition function myFunction ( a , b ) { return a * b ; } //Function use var res = myFunction ( 3 , 2 ); If you do not return anything from a function, it will return undefined.","title":"JavaScript Functions"},{"location":"js_func/#javascript-objects","text":"JavaScript variables are containers for data values. Objects are variables too, but they can contain many values. Think of an object as a list of values that are written as name:value pairs, with the names and the values separated by colons. You can access object properties in two ways. objectName . propertyName //or objectName [ 'propertyName' ] var person = { name : \"John\" , age : 31 , favColor : \"green\" , height : 183 }; var x = person . age ; //the same as: var y = person [ 'age' ]; These values are called properties. JavaScript objects are containers for named values. JavaScript's built-in length property is used to count the number of characters in a property or string. An object method is a property that contains a function definition. Use the following syntax to access an object method. objectName . methodName () Methods are functions that are stored as object properties.","title":"JavaScript Objects"},{"location":"js_func/#constructor-function","text":"Sometimes, we need to set an \"object type\" that can be used to create a number of objects of a single type. The standard way to create an \"object type\" is to use an object constructor function. function person ( name , age , color ) { this . name = name ; this . age = age ; this . favColor = color ; } The above function (person) is an object constructor, which takes parameters and assigns them to the object properties. The this keyword refers to the current object. Note that this is not a variable. It is a keyword, and its value cannot be changed. Once you have an object constructor, you can use the new keyword to create new objects of the same type. var p1 = new person ( \"Amid\" , 42 , \"purple\" ); var p2 = new person ( \"Jessie\" , 39 , \"red\" ); p1 and p2 are now objects of the person type. Their properties are assigned to the corresponding values.","title":"Constructor Function"},{"location":"js_func/#object-initialization","text":"Use the object literal or initializer syntax to create single objects. var John = { name : \"John\" , age : 25 }; var James = { name : \"James\" , age : 21 }; Objects consist of properties, which are used to describe an object. Values of object properties can either contain primitive data types or other objects.","title":"Object Initialization"},{"location":"js_func/#object-methods","text":"Methods are functions that are stored as object properties. Use the following syntax to create an object method: methodName = function () { code lines } Access an object method using the following syntax: objectName . methodName () A method is a function, belonging to an object. It can be referenced using the this keyword. The this keyword is used as a reference to the current object, meaning that you can access the objects properties and methods using it. Defining methods is done inside the constructor function. function person ( name , age , color ) { this . name = name ; this . age = age ; this . changeName = function ( name ){ this . name = name ; } } var p = new person ( \"David\" , 21 ); p . changeName ( \"Jhon\" ); You can also define the function outside of the constructor function and associate it with the object. function person ( name , age ) { this . name = name ; this . age = age ; this . yearOfBirth = bornYear ; } function bornYear () { return 2016 - this . age ; } var p = new person ( \"David\" , 21 ); console . log ( p . yearOfBirth ()); Note that it's not necessary to write the function's parentheses when assigning it to an object. Call the method by the property name you specified in the constructor function, rather than the function name.","title":"Object Methods"},{"location":"js_intro/","text":"String, Variables and Assignments Each statement in JavaScript must end with a semicolon (;) . A comment beginning with two slashes (//) is called a single-line comment. Comments that require multiple lines begin with / and end with / at the end of the comment block. // this is a single-line comment var x = 5 ; // a single-line comment after code /* This is also a comment spanning multiple lines */ JSDocs /** * This is a function. * * @param {string} n - A string param * @return {string} A good string * * @example * * foo('hello') */ function foo ( n ) { return n } Data Types Declaring a variable is as simple as using the keyword var. JavaScript variable names are case-sensitive. The first character of a variable name must be a letter, underscore (_), or a dollar sign ($) (Subsequent characters can be letters, digits, underscores, or dollar signs). The first character of a variable name can\u2019t be a number. Variable names can\u2019t include a mathematical or logical operator in their name. For instance, 2*something or this+that; Variable names can\u2019t contain spaces. You\u2019re not allowed to use any special symbols, like my#num, num%, etc. var x = 10 ; var y = 10.55 ; var name = \"John\" ; var isAlive = true ; var myNull = null ; var myUndefined = undefined ; Single or double quotes, it doesn\u2019t matter, so long as you\u2019re consistent with them. Like this: var name = 'John' ; var text = \"My name is John Smith\" ; You can use quotes inside a string, as long as they don't match the quotes enclosing the string itself. var name = 'John' ; var text = \"My name is 'John' \" ; You can get double quotes inside of double quotes using the escape character like this: \\\" or \\' inside of single quotes. If you start a string with a single quote, then you need to end it with a single quote too. This applies to double quotes. Otherwise, JavaScript will get confused. Booleans var isActive = true ; var isAlive = false ; The Boolean value of 0 (zero), null, undefined, empty string is false. Everything with a \"real\" value is true. First JavaScript Program On the web, JavaScript code lives inside the HTML document, and needs to be enclosed by and : <!doctype html> < html > < head > < meta charset = \"utf-8\" > < title > JavaScript Mastery </ title > </ head > < body > < h1 > JavaScript Mastery </ h1 > < script > document . write ( \"<h1>Hello World!</h1>\" ) console . log ( \"Hello Console!\" ) </ script > </ body > </ html > PopUp Boxes JavaScript offers three types of popup boxes, the Alert, Prompt, and Confirm boxes. Alert Box An alert box is used when you want to ensure that information gets through to the user. When an alert box pops up, the user must click OK to proceed. The alert function takes a single parameter, which is the text displayed in the popup box. To display line breaks within a popup box, use a backslash followed by the character n. alert ( \"Hello World!\\nBye\" ); Be careful when using alert boxes, as the user can continue using the page only after clicking OK. Prompt Box A prompt box is often used to have the user input a value before entering a page. When a prompt box pops up, the user will have to click either OK or Cancel to proceed after entering the input value. If the user clicks OK, the box returns the input value. If the user clicks Cancel, the box returns null. The prompt() method takes two parameters. The first is the label, which you want to display in the text box. The second is a default string to display in the text box (optional). var user = prompt ( \"Enter your name\" ); if ( user != null ) { alert ( \"Hello \" + user ); } else { alert ( \"Bye\" ); } When a prompt box pops up, the user will have to click either \"OK\" or \"Cancel\" to proceed after entering an input value. Do not overuse this method, because it prevents the user from accessing other parts of the page until the box is closed. Confirm Box A confirm box is often used to have the user verify or accept something. When a confirm box pops up, the user must click either OK or Cancel to proceed. If the user clicks OK, the box returns true. If the user clicks Cancel, the box returns false. The confirm() method takes a single parameter, which is the text displayed in the popup box. var result = confirm ( \"Want to exit?\" ); if ( result ) { alert ( \"Bye!\" ); } else { alert ( \"Continue\" ); } Operators An operator is a symbol that performs mathematical or logical manipulations. Javascript supports addition (+), subtraction(-), multiplication(*), division(/) and modulus(%). Also increment (++) and decrement (--). You can get the result of a string expression using the eval() function, which takes a string expression argument like eval(\"10 * 20 + 8\") and returns the result. If the argument is empty, it returns undefined. 10 * '5' or '10' * '5' will give the same result. But trying to multiply a number with string values that aren\u2019t numbers, like 'hello' * 5 will return NaN (Not a Number). In JavaScript, we can use the modulus operator on integers AND on floating point numbers. Exponentiation operator was introduced in ES7. console . log ( 3 ** 4 ); // expected output: 81 console . log ( 10 ** - 2 ); // expected output: 0.01 console . log ( 2 ** 3 ** 2 ); // expected output: 512 console . log (( 2 ** 3 ) ** 2 ); // expected output: 64 User must explicitly enable this feature. The Math Object The Math object allows you to perform mathematical tasks, and includes several properties. Math has no constructor. There's no need to create a Math object first. Math . E //constant e Math . PI //constant pi For exponentiation, we must use Math.pow. to calculate a number raised to the power of some other number. var number = Math . ceil ( Math . random () * 10 ); Math.abs() returns the absolute value of its parameter. Math.ceil() rounds a floating point value up to the nearest integer value. The rounded value is returned as a double Math.floor() rounds a floating point value down to the nearest integer value. Math.max() returns the largest of its parameters. Math.min() returns the smallest parameter. sqrt() for square root, sin() for sine, cos() for cosine Javascript also provides compound assignment operators that perform an operation and an assignment in one statement. In-place operators allow you to write code like 'x = x + 3;' more concisely, as 'x += 3;'. var x = 2 ; x += 3 ; x *= 4 ; x /= 2 ; The increment (and decrement) operator is used to increase (decrease) an integer's value by one. x ++ ; //equivalent to x = x + 1 x -- ; //equivalent to x = x - 1 The increment (and decrement) operator has two forms, prefix and postfix. Prefix increments the value, and then proceeds with the expression. Postfix evaluates the expression and then performs the incrementing. ++ x ; //prefix x ++ ; //postfix Logical Operators (Boolean Operators) Logical operators are used to join multiple expressions and return true or false. The AND operator (&&), the OR operator(||) and the NOT operator(!) The ?: Operator (Conditional (Ternary) Operator) Exp1 ? Exp2 : Exp3; The ?: operator works the following way: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression. var msg = ( age >= 18 ) ? \"Welcome\" : \"Sorry\" ; Exceptions An exception is a problem that occurs during program execution. Exceptions cause abnormal termination of the program. An exception can occur for many different reasons. Some examples: A user has entered invalid data. A file that needs to be opened cannot be found. A network connection has been lost in the middle of communications. Insufficient memory and other issues related to physical resources. JavaScript (similar to Java and C#) provides a flexible mechanism called the try-catch statement to handle exceptions so that a program won't crash when an error occurs. The code that might generate an exception is placed in the try block. If an exception occurs, the catch blocks is executed without stopping the program. The type of exception you want to catch appears in parentheses following the keyword catch. We use the general Exception type to handle all kinds of exceptions. We can also use the exception object e to access the exception details, such as the original error message (e.Message): A single try block can contain multiple catch blocks that handle different exceptions separately. Exception handling is particularly useful when dealing with user input. try { nonExistentFunction (); } catch ( error ) { console . error ( error ); // expected output: ReferenceError: nonExistentFunction is not defined // Note - error messages will vary depending on browser } An optional finally block can be used after the catch blocks. The finally block is used to execute a given set of statements, whether an exception is thrown or not. try { try_statements } catch ( exception_var ) { catch_statements } finally { finally_statements } try { myroutine (); // may throw three types of exceptions } catch ( e ) { if ( e instanceof TypeError ) { // statements to handle TypeError exceptions } else if ( e instanceof RangeError ) { // statements to handle RangeError exceptions } else if ( e instanceof EvalError ) { // statements to handle EvalError exceptions } else { // statements to handle any unspecified exceptions logMyErrors ( e ); // pass exception object to error handler } } throw The throw keyword allows you to manually generate exceptions from your methods. A common use case for this is to only catch (and silence) a small subset of expected errors, and then re-throw the error in other cases: try { myRoutine (); } catch ( e ) { if ( e instanceof RangeError ) { // statements to handle this very common expected error } else { throw e ; // re-throw the error unchanged } } JavaScript Arrays An array is a special type of object. An array uses numbers to access its elements, and an object uses names to access its members. var courses = new Array ( 3 ); courses [ 0 ] = \"HTML\" ; courses [ 1 ] = \"CSS\" ; courses [ 2 ] = \"JS\" ; You refer to an array element by referring to the index number written in square brackets. This statement accesses the value of the first element in courses and changes the value of the second element. var courses = new Array ( \"HTML\" , \"CSS\" , \"JS\" ); var course = courses [ 0 ]; // HTML courses [ 1 ] = \"C++\" ; //Changes the second element JS[0] is the first element in an array. [1] is the second. Array indexes start with 0. Attempting to access an index outside of the array, returns the value undefined. JavaScript arrays are dynamic, so you can declare an array and not pass any arguments with the Array() constructor. You can then add the elements dynamically. var courses = new Array (); courses [ 0 ] = \"HTML\" ; courses [ 1 ] = \"CSS\" ; courses [ 2 ] = \"JS\" ; courses [ 3 ] = \"CS\" ; Array Literal For greater simplicity, readability, and execution speed, you can also declare arrays using the array literal syntax. var course = [ \"HTML\" , \"CSS\" ; \"JS\" ]; This results in the same array as the one created with the new Array() syntax. You can access and modify the elements of the array using the index number, as you did before. The array literal syntax is the recommended way to declare arrays. Arrays Properties and Methods The length property returns the number of elements of the array. The length property is always one more than the highest array index. If the array is empty, the length property returns 0. JavaScript's concat() method allows you to join arrays and create an entirely new array. var c1 = [ \"HTML\" , \"CSS\" ]; var c2 = [ \"JS\" , \"CS\" ]; var courses = c1 . concat ( c2 ); The concat operation does not affect the c1 and c2 arrays - it returns the resulting concatenation as a new array. Associative Arrays Remember that JavaScript does not support arrays with named indexes. In JavaScript, arrays always use numbered indexes. It is better to use an object when you want the index to be a string (text). Use an array when you want the index to be a number. If you use a named index, JavaScript will redefine the array to a standard object. Date Object setInterval The setInterval() method calls a function or evaluates an expression at specified intervals (in milliseconds). It will continue calling the function until clearInterval() is called or the window is closed. function myAlert ()[ alert ( \"HI\" ); } setInterval ( myAlert , 3000 ); This will call the myAlert function every 3 seconds (1000 ms = 1 second). Write the name of the function without parentheses when passing it into the setInterval method. The Date object enables us to work with dates. A date consists of a year, a month, a day, an hour, a minute, a second, and milliseconds. Using new Date(), create a new date object with the current date and time var d = new Date (); //d stores the current date and time The other ways to initialize dates allow for the creation of new date objects from the specified date and time new Date(milliseconds) new Date(dateString) new Date(year, month, day, hours, minutes, seconds, milliseconds) JavaScript dates are calculated in milliseconds from 01 January, 1970 00:00:00 Universal Time (UTC). One day contains 86,400,000 millisecond. For example: //Fri Jan 02 1970 00:00:00 var d1 = new Date ( 86400000 ); //Fri Jan 02 2015 10:42:00 var d2 = new Date ( \"January 2, 2015 10:42:00\" ); //Sat Jun 11 1988 11:42:00 var d3 = new Date ( 88 , 5 , 11 , 11 , 42 , 0 , 0 ); JavaScript counts months from 0 to 11. January is 0, and December is 11. Date objects are static, rather than dynamic. The computer time is ticking, but date objects don't change, once created. When a Date object is created, a number of methods make it possible to perform operations on it. getMonth(), getDate(), getDay(),etc\u2026 var d = new Date (); var hours = d . getHours (); //hours equals to the current hour Control Flow For-Loops A for loop executes a set of statements a specific number of times. The init and increment statements may be left out, if not needed, but remember that the semicolons are mandatory. for (; ;) {} is an infinite loop. for ( var i = 0 ; i < 10 ; i ++ ) { //...; } While-Loops A while loop repeatedly executes a block of code as long as a given condition is true. var num = 1 ; while ( num < 6 ) { console . log ( num ); num ++ ; } Do-While Loops A do-while loop is similar to a while loop, except that a do-while loop is guaranteed to execute at least one time. var a = 0 ; do { console . log ( a ); a ++ ; } while ( a < 5 ); Conditionals The general form of the if statement is: if ( x == 3 ) { //.... } else if ( x == 0 ) { //.... } else { //.... } Use relational operators (Comparison Operators) to evaluate conditions. They only work when they\u2019re comparing the same data type; numbers with numbers, strings with strings. In addition to the less than (<) and greater than (>) operators, the following operators are available: >=, <=, ==(Equal to), !=(Not Equal to), ===(Identical, Equal and same type), !==(Not identical). Remember, that an if can have zero or more else if's and they must come before the last else, which is optional. Once an else if succeeds, none of the remaining else if's or else clause will be tested. The switch statement provides a more elegant way to test a variable for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each switch case. The default code executes when none of the cases matches the switch expression. // Or using a switch: switch ( x ) { case 3 : // ... break ; case 0 : // ... break ; default : // ... break ; } Break and Continue When the break statement is encountered inside a loop, the loop is immediately terminated and the program execution moves on to the next statement following the loop body. If you are using nested loops (i.e., one loop inside another loop), the break statement will stop the execution of the innermost loop and start executing the next line of code after the block. The continue statement is similar to the break statement, but instead of terminating the loop entirely, it skips the current iteration of the loop and continues with the next iteration. for ( var i = 0 ; i < 10 ; i ++ ) { if ( i % 2 == 0 ) continue ; if ( i == 6 ) break ; console . log ( i ); }","title":"Intro"},{"location":"js_intro/#string-variables-and-assignments","text":"Each statement in JavaScript must end with a semicolon (;) . A comment beginning with two slashes (//) is called a single-line comment. Comments that require multiple lines begin with / and end with / at the end of the comment block. // this is a single-line comment var x = 5 ; // a single-line comment after code /* This is also a comment spanning multiple lines */","title":"String, Variables and Assignments"},{"location":"js_intro/#jsdocs","text":"/** * This is a function. * * @param {string} n - A string param * @return {string} A good string * * @example * * foo('hello') */ function foo ( n ) { return n }","title":"JSDocs"},{"location":"js_intro/#data-types","text":"Declaring a variable is as simple as using the keyword var. JavaScript variable names are case-sensitive. The first character of a variable name must be a letter, underscore (_), or a dollar sign ($) (Subsequent characters can be letters, digits, underscores, or dollar signs). The first character of a variable name can\u2019t be a number. Variable names can\u2019t include a mathematical or logical operator in their name. For instance, 2*something or this+that; Variable names can\u2019t contain spaces. You\u2019re not allowed to use any special symbols, like my#num, num%, etc. var x = 10 ; var y = 10.55 ; var name = \"John\" ; var isAlive = true ; var myNull = null ; var myUndefined = undefined ; Single or double quotes, it doesn\u2019t matter, so long as you\u2019re consistent with them. Like this: var name = 'John' ; var text = \"My name is John Smith\" ; You can use quotes inside a string, as long as they don't match the quotes enclosing the string itself. var name = 'John' ; var text = \"My name is 'John' \" ; You can get double quotes inside of double quotes using the escape character like this: \\\" or \\' inside of single quotes. If you start a string with a single quote, then you need to end it with a single quote too. This applies to double quotes. Otherwise, JavaScript will get confused.","title":"Data Types"},{"location":"js_intro/#booleans","text":"var isActive = true ; var isAlive = false ; The Boolean value of 0 (zero), null, undefined, empty string is false. Everything with a \"real\" value is true.","title":"Booleans"},{"location":"js_intro/#first-javascript-program","text":"On the web, JavaScript code lives inside the HTML document, and needs to be enclosed by and : <!doctype html> < html > < head > < meta charset = \"utf-8\" > < title > JavaScript Mastery </ title > </ head > < body > < h1 > JavaScript Mastery </ h1 > < script > document . write ( \"<h1>Hello World!</h1>\" ) console . log ( \"Hello Console!\" ) </ script > </ body > </ html >","title":"First JavaScript Program"},{"location":"js_intro/#popup-boxes","text":"JavaScript offers three types of popup boxes, the Alert, Prompt, and Confirm boxes.","title":"PopUp Boxes"},{"location":"js_intro/#alert-box","text":"An alert box is used when you want to ensure that information gets through to the user. When an alert box pops up, the user must click OK to proceed. The alert function takes a single parameter, which is the text displayed in the popup box. To display line breaks within a popup box, use a backslash followed by the character n. alert ( \"Hello World!\\nBye\" ); Be careful when using alert boxes, as the user can continue using the page only after clicking OK.","title":"Alert Box"},{"location":"js_intro/#prompt-box","text":"A prompt box is often used to have the user input a value before entering a page. When a prompt box pops up, the user will have to click either OK or Cancel to proceed after entering the input value. If the user clicks OK, the box returns the input value. If the user clicks Cancel, the box returns null. The prompt() method takes two parameters. The first is the label, which you want to display in the text box. The second is a default string to display in the text box (optional). var user = prompt ( \"Enter your name\" ); if ( user != null ) { alert ( \"Hello \" + user ); } else { alert ( \"Bye\" ); } When a prompt box pops up, the user will have to click either \"OK\" or \"Cancel\" to proceed after entering an input value. Do not overuse this method, because it prevents the user from accessing other parts of the page until the box is closed.","title":"Prompt Box"},{"location":"js_intro/#confirm-box","text":"A confirm box is often used to have the user verify or accept something. When a confirm box pops up, the user must click either OK or Cancel to proceed. If the user clicks OK, the box returns true. If the user clicks Cancel, the box returns false. The confirm() method takes a single parameter, which is the text displayed in the popup box. var result = confirm ( \"Want to exit?\" ); if ( result ) { alert ( \"Bye!\" ); } else { alert ( \"Continue\" ); }","title":"Confirm Box"},{"location":"js_intro/#operators","text":"An operator is a symbol that performs mathematical or logical manipulations. Javascript supports addition (+), subtraction(-), multiplication(*), division(/) and modulus(%). Also increment (++) and decrement (--). You can get the result of a string expression using the eval() function, which takes a string expression argument like eval(\"10 * 20 + 8\") and returns the result. If the argument is empty, it returns undefined. 10 * '5' or '10' * '5' will give the same result. But trying to multiply a number with string values that aren\u2019t numbers, like 'hello' * 5 will return NaN (Not a Number). In JavaScript, we can use the modulus operator on integers AND on floating point numbers. Exponentiation operator was introduced in ES7. console . log ( 3 ** 4 ); // expected output: 81 console . log ( 10 ** - 2 ); // expected output: 0.01 console . log ( 2 ** 3 ** 2 ); // expected output: 512 console . log (( 2 ** 3 ) ** 2 ); // expected output: 64 User must explicitly enable this feature.","title":"Operators"},{"location":"js_intro/#the-math-object","text":"The Math object allows you to perform mathematical tasks, and includes several properties. Math has no constructor. There's no need to create a Math object first. Math . E //constant e Math . PI //constant pi For exponentiation, we must use Math.pow. to calculate a number raised to the power of some other number. var number = Math . ceil ( Math . random () * 10 ); Math.abs() returns the absolute value of its parameter. Math.ceil() rounds a floating point value up to the nearest integer value. The rounded value is returned as a double Math.floor() rounds a floating point value down to the nearest integer value. Math.max() returns the largest of its parameters. Math.min() returns the smallest parameter. sqrt() for square root, sin() for sine, cos() for cosine Javascript also provides compound assignment operators that perform an operation and an assignment in one statement. In-place operators allow you to write code like 'x = x + 3;' more concisely, as 'x += 3;'. var x = 2 ; x += 3 ; x *= 4 ; x /= 2 ; The increment (and decrement) operator is used to increase (decrease) an integer's value by one. x ++ ; //equivalent to x = x + 1 x -- ; //equivalent to x = x - 1 The increment (and decrement) operator has two forms, prefix and postfix. Prefix increments the value, and then proceeds with the expression. Postfix evaluates the expression and then performs the incrementing. ++ x ; //prefix x ++ ; //postfix","title":"The Math Object"},{"location":"js_intro/#logical-operators","text":"(Boolean Operators) Logical operators are used to join multiple expressions and return true or false. The AND operator (&&), the OR operator(||) and the NOT operator(!)","title":"Logical Operators"},{"location":"js_intro/#the-operator","text":"(Conditional (Ternary) Operator) Exp1 ? Exp2 : Exp3; The ?: operator works the following way: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression. var msg = ( age >= 18 ) ? \"Welcome\" : \"Sorry\" ;","title":"The ?: Operator"},{"location":"js_intro/#exceptions","text":"An exception is a problem that occurs during program execution. Exceptions cause abnormal termination of the program. An exception can occur for many different reasons. Some examples: A user has entered invalid data. A file that needs to be opened cannot be found. A network connection has been lost in the middle of communications. Insufficient memory and other issues related to physical resources. JavaScript (similar to Java and C#) provides a flexible mechanism called the try-catch statement to handle exceptions so that a program won't crash when an error occurs. The code that might generate an exception is placed in the try block. If an exception occurs, the catch blocks is executed without stopping the program. The type of exception you want to catch appears in parentheses following the keyword catch. We use the general Exception type to handle all kinds of exceptions. We can also use the exception object e to access the exception details, such as the original error message (e.Message): A single try block can contain multiple catch blocks that handle different exceptions separately. Exception handling is particularly useful when dealing with user input. try { nonExistentFunction (); } catch ( error ) { console . error ( error ); // expected output: ReferenceError: nonExistentFunction is not defined // Note - error messages will vary depending on browser } An optional finally block can be used after the catch blocks. The finally block is used to execute a given set of statements, whether an exception is thrown or not. try { try_statements } catch ( exception_var ) { catch_statements } finally { finally_statements } try { myroutine (); // may throw three types of exceptions } catch ( e ) { if ( e instanceof TypeError ) { // statements to handle TypeError exceptions } else if ( e instanceof RangeError ) { // statements to handle RangeError exceptions } else if ( e instanceof EvalError ) { // statements to handle EvalError exceptions } else { // statements to handle any unspecified exceptions logMyErrors ( e ); // pass exception object to error handler } }","title":"Exceptions"},{"location":"js_intro/#throw","text":"The throw keyword allows you to manually generate exceptions from your methods. A common use case for this is to only catch (and silence) a small subset of expected errors, and then re-throw the error in other cases: try { myRoutine (); } catch ( e ) { if ( e instanceof RangeError ) { // statements to handle this very common expected error } else { throw e ; // re-throw the error unchanged } }","title":"throw"},{"location":"js_intro/#javascript-arrays","text":"An array is a special type of object. An array uses numbers to access its elements, and an object uses names to access its members. var courses = new Array ( 3 ); courses [ 0 ] = \"HTML\" ; courses [ 1 ] = \"CSS\" ; courses [ 2 ] = \"JS\" ; You refer to an array element by referring to the index number written in square brackets. This statement accesses the value of the first element in courses and changes the value of the second element. var courses = new Array ( \"HTML\" , \"CSS\" , \"JS\" ); var course = courses [ 0 ]; // HTML courses [ 1 ] = \"C++\" ; //Changes the second element JS[0] is the first element in an array. [1] is the second. Array indexes start with 0. Attempting to access an index outside of the array, returns the value undefined. JavaScript arrays are dynamic, so you can declare an array and not pass any arguments with the Array() constructor. You can then add the elements dynamically. var courses = new Array (); courses [ 0 ] = \"HTML\" ; courses [ 1 ] = \"CSS\" ; courses [ 2 ] = \"JS\" ; courses [ 3 ] = \"CS\" ;","title":"JavaScript Arrays"},{"location":"js_intro/#array-literal","text":"For greater simplicity, readability, and execution speed, you can also declare arrays using the array literal syntax. var course = [ \"HTML\" , \"CSS\" ; \"JS\" ]; This results in the same array as the one created with the new Array() syntax. You can access and modify the elements of the array using the index number, as you did before. The array literal syntax is the recommended way to declare arrays.","title":"Array Literal"},{"location":"js_intro/#arrays-properties-and-methods","text":"The length property returns the number of elements of the array. The length property is always one more than the highest array index. If the array is empty, the length property returns 0. JavaScript's concat() method allows you to join arrays and create an entirely new array. var c1 = [ \"HTML\" , \"CSS\" ]; var c2 = [ \"JS\" , \"CS\" ]; var courses = c1 . concat ( c2 ); The concat operation does not affect the c1 and c2 arrays - it returns the resulting concatenation as a new array.","title":"Arrays Properties and Methods"},{"location":"js_intro/#associative-arrays","text":"Remember that JavaScript does not support arrays with named indexes. In JavaScript, arrays always use numbered indexes. It is better to use an object when you want the index to be a string (text). Use an array when you want the index to be a number. If you use a named index, JavaScript will redefine the array to a standard object.","title":"Associative Arrays"},{"location":"js_intro/#date-object","text":"","title":"Date Object"},{"location":"js_intro/#setinterval","text":"The setInterval() method calls a function or evaluates an expression at specified intervals (in milliseconds). It will continue calling the function until clearInterval() is called or the window is closed. function myAlert ()[ alert ( \"HI\" ); } setInterval ( myAlert , 3000 ); This will call the myAlert function every 3 seconds (1000 ms = 1 second). Write the name of the function without parentheses when passing it into the setInterval method. The Date object enables us to work with dates. A date consists of a year, a month, a day, an hour, a minute, a second, and milliseconds. Using new Date(), create a new date object with the current date and time var d = new Date (); //d stores the current date and time The other ways to initialize dates allow for the creation of new date objects from the specified date and time new Date(milliseconds) new Date(dateString) new Date(year, month, day, hours, minutes, seconds, milliseconds) JavaScript dates are calculated in milliseconds from 01 January, 1970 00:00:00 Universal Time (UTC). One day contains 86,400,000 millisecond. For example: //Fri Jan 02 1970 00:00:00 var d1 = new Date ( 86400000 ); //Fri Jan 02 2015 10:42:00 var d2 = new Date ( \"January 2, 2015 10:42:00\" ); //Sat Jun 11 1988 11:42:00 var d3 = new Date ( 88 , 5 , 11 , 11 , 42 , 0 , 0 ); JavaScript counts months from 0 to 11. January is 0, and December is 11. Date objects are static, rather than dynamic. The computer time is ticking, but date objects don't change, once created. When a Date object is created, a number of methods make it possible to perform operations on it. getMonth(), getDate(), getDay(),etc\u2026 var d = new Date (); var hours = d . getHours (); //hours equals to the current hour","title":"setInterval"},{"location":"js_intro/#control-flow","text":"","title":"Control Flow"},{"location":"js_intro/#for-loops","text":"A for loop executes a set of statements a specific number of times. The init and increment statements may be left out, if not needed, but remember that the semicolons are mandatory. for (; ;) {} is an infinite loop. for ( var i = 0 ; i < 10 ; i ++ ) { //...; }","title":"For-Loops"},{"location":"js_intro/#while-loops","text":"A while loop repeatedly executes a block of code as long as a given condition is true. var num = 1 ; while ( num < 6 ) { console . log ( num ); num ++ ; }","title":"While-Loops"},{"location":"js_intro/#do-while-loops","text":"A do-while loop is similar to a while loop, except that a do-while loop is guaranteed to execute at least one time. var a = 0 ; do { console . log ( a ); a ++ ; } while ( a < 5 );","title":"Do-While Loops"},{"location":"js_intro/#conditionals","text":"The general form of the if statement is: if ( x == 3 ) { //.... } else if ( x == 0 ) { //.... } else { //.... } Use relational operators (Comparison Operators) to evaluate conditions. They only work when they\u2019re comparing the same data type; numbers with numbers, strings with strings. In addition to the less than (<) and greater than (>) operators, the following operators are available: >=, <=, ==(Equal to), !=(Not Equal to), ===(Identical, Equal and same type), !==(Not identical). Remember, that an if can have zero or more else if's and they must come before the last else, which is optional. Once an else if succeeds, none of the remaining else if's or else clause will be tested. The switch statement provides a more elegant way to test a variable for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each switch case. The default code executes when none of the cases matches the switch expression. // Or using a switch: switch ( x ) { case 3 : // ... break ; case 0 : // ... break ; default : // ... break ; }","title":"Conditionals"},{"location":"js_intro/#break-and-continue","text":"When the break statement is encountered inside a loop, the loop is immediately terminated and the program execution moves on to the next statement following the loop body. If you are using nested loops (i.e., one loop inside another loop), the break statement will stop the execution of the innermost loop and start executing the next line of code after the block. The continue statement is similar to the break statement, but instead of terminating the loop entirely, it skips the current iteration of the loop and continues with the next iteration. for ( var i = 0 ; i < 10 ; i ++ ) { if ( i % 2 == 0 ) continue ; if ( i == 6 ) break ; console . log ( i ); }","title":"Break and Continue"}]}