{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JavaScript Mastery JavaScript is the backbone of modern web development. Whether you're a beginner taking your first steps or an experienced coder looking to sharpen your skills, this website will guide you through the world of JavaScript. JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g. functional programming) styles. Topic Description Introduction to JavaScript Understanding syntax, variables, and data types. Functions and Scope Mastering functions, closures, and scope. DOM Manipulation How JavaScript interacts with HTML and CSS. Event Handling Making web pages interactive with events. Asynchronous JavaScript Understanding callbacks, promises, and async/await. Object-Oriented JavaScript Exploring prototypes, classes, and inheritance. JavaScript Frameworks Overview of React, Vue, and Angular. Advanced Concepts Performance optimization, design patterns, and best practices. References JavaScript Guide Contribute Help us improve this tutorial! If you find any issues or have suggestions, please report them on our GitHub repository .","title":"Home"},{"location":"#javascript-mastery","text":"JavaScript is the backbone of modern web development. Whether you're a beginner taking your first steps or an experienced coder looking to sharpen your skills, this website will guide you through the world of JavaScript. JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g. functional programming) styles. Topic Description Introduction to JavaScript Understanding syntax, variables, and data types. Functions and Scope Mastering functions, closures, and scope. DOM Manipulation How JavaScript interacts with HTML and CSS. Event Handling Making web pages interactive with events. Asynchronous JavaScript Understanding callbacks, promises, and async/await. Object-Oriented JavaScript Exploring prototypes, classes, and inheritance. JavaScript Frameworks Overview of React, Vue, and Angular. Advanced Concepts Performance optimization, design patterns, and best practices.","title":"JavaScript Mastery"},{"location":"#references","text":"JavaScript Guide","title":"References"},{"location":"#contribute","text":"Help us improve this tutorial! If you find any issues or have suggestions, please report them on our GitHub repository .","title":"Contribute"},{"location":"angular/","text":"The Angular Framework Angular is a front-end JavaScript framework. A framework is a set of connected libraries designed around a specific programming language. Frameworks provide conventions that support doing things a certain way. A front-end framework typically has specific conventions around how HTML is handled, how forms are created, how interactive elements on a web page are handled, how variables are interpolated inside of HTML views, etc. AngularJS or Angular 1.x was the first iteration of the Angular framework. With the release of Angular 2, Angular was completely redesigned using TypeScript and component based architecture. Although component based architecture was available in the later releases of Angular 1.x, components are now the very foundation of Angular 2 and all subsequent releases after version 2. After 2, Angular 4 was released and versions counted upwards from there (there was no version 3). It is important to know that when developers say Angular, they mean Angular versions 2 and higher. AngularJS refers to version 1 of Angular only. DataTypes AngularJS used Javascript as its primary language. Angular began using TypeScript starting in Angular 2. Since then, TypeScript has become the primary language of Angular. Strings in TypeScript Variables in TypeScript can be statically typed. Statically typed variables must always retain the data type that they start out with. Once a variable is statically typed as a string, for example, that variable cannot hold any other data type. TypeScript uses JavaScript\u2019s var, let, and const keywords to initialize variables. It also uses a colon after the variable name to designate the type. Javascript: let name = 'Fred' console . log ( name ) TypeScript: let name : string = 'Fred' console . log ( name ) Based on this convention, we could initialize a shoeColor string in TypeScript as such: let shoeColor : string = 'blue' ; console . log ( shoeColor ); It is possible to change variable values over time: shoeColor = 'red' ; console . log ( shoeColor ); // Now \"shoeColor\" has a value of red. Note that once a variable has been typed, you don't have to declare a type again when the value of the variable changes. TypeScript does not require you to statically type variables. Plain Javascript syntax WILL work in TypeScript. However, by convention, most programmers statically type variables in TypeScript because it helps to provide structure and prevent programmer errors. Numbers in TypeScript Another TypeScript data type is the number data type. We can initialize a seatCount number variable in TypeScript like this: let seatCount : number = 42 ; console . log ( seatCount ); TypeScript does not designate between integers and floating point or decimal numbers like other languages when it comes to typing. Initializing a decimal number is just like initializing an integer: let registrationPercentage : number = 92.87 ; console . log ( registrationPercentage ); Note that registrationPercentage will always have to be of a number type. If you were to try to reassign registrationPercentage to a string value in another line of that program, the program would not compile, and your text editor would most likely throw an error. registrationPercentage = 'Ninety Two' ; // WILL CAUSE AN ERROR because registrationPercentage is statically typed as a number. Typescript includes all methods that you are used to using in JavaScript. For example, string methods like parseInt() and parseFloat() that return numbers will also work in TypeScript. Booleans in TypeScript Boolean values are either true or false. In TypeScript, you can declare and statically type a variable without initializing it with a value. For example: let isRegistered : boolean ; console . log ( isRegistered ); // undefined If you try to use isRegistered at this point in the program, however, you will get an error. Some programmers declare variables and type them without initializing them because the value of the variable is completely unknown at the start of the program. Later, you can assign it. isRegistered = false ; console . log ( isRegistered ); // false Booleans always return true or false values. These values are not strings, they are actually their own data type. Enums in TypeScript Enum values in Typescript are collections of constants. Think of an Enum as a type of fixed array of things that you use as a reference, such as days of the week, states in the USA, etc. The number of elements never changes during the run of the program and the order of elements doesn\u2019t change either. Let\u2019s create an enum called spiceLevel: enum spiceLevel { NONE = \"no spice\" , LOW = \"barely spicy\" , MEDIUM = \"medium spicy\" , HIGH = \"hot\" } console . log ( spiceLevel . MEDIUM ); // outputs \"medium spicy\" Modern Integrated development environments ( IDEs ) like Visual Studio Code help you complete enum values and other coding constructs by using autocomplete. Enums help to ensure that commonly used constants in your program are all consistent. This helps to avoid typos and general errors. The 'any' Type in TypeScript Finally, we will examine the any data type. The 'any' type is essentially a wild card. It can hold anything. We can declare an 'any' data type in TypeScript like this: let userData : any ; userData will now be a container that can hold any data type. Once userData is initialized, however, it will infer the type from the value given to it. let userData : any ; userData = 22 ; console . log ( userData + 2 ); // logs 24 userData = \"free\" ; console . log ( userData + \"man\" ); // logs \"freeman\"; Note that with an any data type, even though the type is inferred upon assignment, you can re-assign the variable to another data type and it still works. Why in the world would you ever need an 'any' type? Well, in certain situations, like getting user data from a server, you might be accepting variable data that could conceivably be of any data type. Any types not only accommodate data from any source, but they also signal to other developers the fact that this particular variable is of an unknown type and that the data should be handled with care. Custom Types If you thought for a minute that TypeScript was limited to number, string, boolean, and other familiar types, then we have a pleasant surprise for you! In TypeScript, you can create your OWN types and use them the same way that you would primitive types like numbers and strings. One way to do this is by creating an interface. An interface in TypeScript is a data structure that defines the shape of data. Let\u2019s see this in action: interface Order { customerName : string , itemNumbers : number [], isComplete : boolean } The interface keyword is used to initialize an interface, which shows us the SHAPE of the data that\u2019s coming. Think of an interface like a factory mold. This interface is used to stamp out Order types for a store. Now let\u2019s actually use the Order interface to type a variable: let order1 : Order ; order1 = { customerName : \"Abiye\" , itemNumbers : [ 123 , 44 , 232 ], isComplete : false } Let\u2019s analyze the order1 variable. It is of an \"Order\" type, so it must have 3 fields: the first field is a string, the second field is an array of integers, and the third field is a boolean. It MUST have each of those fields in order to fulfill the contract of the interface. Try omitting one of the fields in order1 (for example, remove the customerName). You will receive an error because the contract has not been fulfilled. An interface contract is simply the list of fields in that interface that any variable needs if it wants to use that type. All of the normal fields within an interface must be implemented in any variable that uses that type. Optional Fields in Interfaces","title":"Angular"},{"location":"angular/#the-angular-framework","text":"Angular is a front-end JavaScript framework. A framework is a set of connected libraries designed around a specific programming language. Frameworks provide conventions that support doing things a certain way. A front-end framework typically has specific conventions around how HTML is handled, how forms are created, how interactive elements on a web page are handled, how variables are interpolated inside of HTML views, etc. AngularJS or Angular 1.x was the first iteration of the Angular framework. With the release of Angular 2, Angular was completely redesigned using TypeScript and component based architecture. Although component based architecture was available in the later releases of Angular 1.x, components are now the very foundation of Angular 2 and all subsequent releases after version 2. After 2, Angular 4 was released and versions counted upwards from there (there was no version 3). It is important to know that when developers say Angular, they mean Angular versions 2 and higher. AngularJS refers to version 1 of Angular only.","title":"The Angular Framework"},{"location":"angular/#datatypes","text":"AngularJS used Javascript as its primary language. Angular began using TypeScript starting in Angular 2. Since then, TypeScript has become the primary language of Angular.","title":"DataTypes"},{"location":"angular/#strings-in-typescript","text":"Variables in TypeScript can be statically typed. Statically typed variables must always retain the data type that they start out with. Once a variable is statically typed as a string, for example, that variable cannot hold any other data type. TypeScript uses JavaScript\u2019s var, let, and const keywords to initialize variables. It also uses a colon after the variable name to designate the type. Javascript: let name = 'Fred' console . log ( name ) TypeScript: let name : string = 'Fred' console . log ( name ) Based on this convention, we could initialize a shoeColor string in TypeScript as such: let shoeColor : string = 'blue' ; console . log ( shoeColor ); It is possible to change variable values over time: shoeColor = 'red' ; console . log ( shoeColor ); // Now \"shoeColor\" has a value of red. Note that once a variable has been typed, you don't have to declare a type again when the value of the variable changes. TypeScript does not require you to statically type variables. Plain Javascript syntax WILL work in TypeScript. However, by convention, most programmers statically type variables in TypeScript because it helps to provide structure and prevent programmer errors.","title":"Strings in TypeScript"},{"location":"angular/#numbers-in-typescript","text":"Another TypeScript data type is the number data type. We can initialize a seatCount number variable in TypeScript like this: let seatCount : number = 42 ; console . log ( seatCount ); TypeScript does not designate between integers and floating point or decimal numbers like other languages when it comes to typing. Initializing a decimal number is just like initializing an integer: let registrationPercentage : number = 92.87 ; console . log ( registrationPercentage ); Note that registrationPercentage will always have to be of a number type. If you were to try to reassign registrationPercentage to a string value in another line of that program, the program would not compile, and your text editor would most likely throw an error. registrationPercentage = 'Ninety Two' ; // WILL CAUSE AN ERROR because registrationPercentage is statically typed as a number. Typescript includes all methods that you are used to using in JavaScript. For example, string methods like parseInt() and parseFloat() that return numbers will also work in TypeScript.","title":"Numbers in TypeScript"},{"location":"angular/#booleans-in-typescript","text":"Boolean values are either true or false. In TypeScript, you can declare and statically type a variable without initializing it with a value. For example: let isRegistered : boolean ; console . log ( isRegistered ); // undefined If you try to use isRegistered at this point in the program, however, you will get an error. Some programmers declare variables and type them without initializing them because the value of the variable is completely unknown at the start of the program. Later, you can assign it. isRegistered = false ; console . log ( isRegistered ); // false Booleans always return true or false values. These values are not strings, they are actually their own data type.","title":"Booleans in TypeScript"},{"location":"angular/#enums-in-typescript","text":"Enum values in Typescript are collections of constants. Think of an Enum as a type of fixed array of things that you use as a reference, such as days of the week, states in the USA, etc. The number of elements never changes during the run of the program and the order of elements doesn\u2019t change either. Let\u2019s create an enum called spiceLevel: enum spiceLevel { NONE = \"no spice\" , LOW = \"barely spicy\" , MEDIUM = \"medium spicy\" , HIGH = \"hot\" } console . log ( spiceLevel . MEDIUM ); // outputs \"medium spicy\" Modern Integrated development environments ( IDEs ) like Visual Studio Code help you complete enum values and other coding constructs by using autocomplete. Enums help to ensure that commonly used constants in your program are all consistent. This helps to avoid typos and general errors.","title":"Enums in TypeScript"},{"location":"angular/#the-any-type-in-typescript","text":"Finally, we will examine the any data type. The 'any' type is essentially a wild card. It can hold anything. We can declare an 'any' data type in TypeScript like this: let userData : any ; userData will now be a container that can hold any data type. Once userData is initialized, however, it will infer the type from the value given to it. let userData : any ; userData = 22 ; console . log ( userData + 2 ); // logs 24 userData = \"free\" ; console . log ( userData + \"man\" ); // logs \"freeman\"; Note that with an any data type, even though the type is inferred upon assignment, you can re-assign the variable to another data type and it still works. Why in the world would you ever need an 'any' type? Well, in certain situations, like getting user data from a server, you might be accepting variable data that could conceivably be of any data type. Any types not only accommodate data from any source, but they also signal to other developers the fact that this particular variable is of an unknown type and that the data should be handled with care.","title":"The 'any' Type in TypeScript"},{"location":"angular/#custom-types","text":"If you thought for a minute that TypeScript was limited to number, string, boolean, and other familiar types, then we have a pleasant surprise for you! In TypeScript, you can create your OWN types and use them the same way that you would primitive types like numbers and strings. One way to do this is by creating an interface. An interface in TypeScript is a data structure that defines the shape of data. Let\u2019s see this in action: interface Order { customerName : string , itemNumbers : number [], isComplete : boolean } The interface keyword is used to initialize an interface, which shows us the SHAPE of the data that\u2019s coming. Think of an interface like a factory mold. This interface is used to stamp out Order types for a store. Now let\u2019s actually use the Order interface to type a variable: let order1 : Order ; order1 = { customerName : \"Abiye\" , itemNumbers : [ 123 , 44 , 232 ], isComplete : false } Let\u2019s analyze the order1 variable. It is of an \"Order\" type, so it must have 3 fields: the first field is a string, the second field is an array of integers, and the third field is a boolean. It MUST have each of those fields in order to fulfill the contract of the interface. Try omitting one of the fields in order1 (for example, remove the customerName). You will receive an error because the contract has not been fulfilled. An interface contract is simply the list of fields in that interface that any variable needs if it wants to use that type. All of the normal fields within an interface must be implemented in any variable that uses that type.","title":"Custom Types"},{"location":"angular/#optional-fields-in-interfaces","text":"","title":"Optional Fields in Interfaces"},{"location":"fullstack/","text":"The Concept of Web Stacks Often you will hear programmers referring to various stacks in web development. In the last several years we have seen the proliferation of many stacks, including: MEAN (Mongo, Express, Angular and Node) LAMP (Linux, Apache, MySQL and PHP) Python-Django Ruby on Rails .NET It\u2019s important to understand that these stacks are constantly being invented, reinvented, iterated upon, and mixed with other stacks. The MEAN stack evolved into the PEAN or NEAP stack when some developers started switching back to using Postgresql instead of Mongo for the database resource related to that particular stack. Stack is not a technical term. It is a loose term and can be very fluid and sometimes even subjective. It is important, however, to be able to articulate which stacks you feel most comfortable with when you become a full stack developer. For example, a TypeScript based stack can use Angular and NestJS, one of the newer stacks in web development. JavaScript and TypeScript can be used in BOTH the front and the back-end of the stack. JavaScript and TypeScript throughout the Stack JavaScript became a popular full stack tool in 2009 after NodeJS was released. Prior to the release of NodeJS, JavaScript was seen as primarily a front-end only tool used for creating widgets, user activity on a page, DOM (web page structure) manipulation and other front-end only tasks. After NodeJS was released, JavaScript was seen as a great tool for creating back-ends and front-ends alike. TypeScript was released in 2012 by Microsoft because many JavaScript developers had expressed the desire for more structure and clear data types, especially for use in large scale applications. TypeScript has some features like static variable typing and interfaces that are present in well-respected legacy languages like Java and C#. TypeScript is a superset of JavaScript. What this means is that TypeScript is transpiled into JavaScript. It\u2019s literally translated into JavaScript code when it is compiled and before it is run. TypeScript is Translated into JavaScript. That\u2019s an important concept to remember! It therefore made logical sense, upon the release of NestJS, that TypeScript could be used throughout the entire web application stack just like JavaScript had been. One of the creators of Typescript was Microsoft employee Anders Hejlsberg, the creator of C#. XHR The next concept to understand is the request / response nature of full stack applications. In a restaurant, the food request comes from the dining room, or the front-end. The customer makes a request to the kitchen. In web applications, this typically comes in the form of an XML/HTTP Request or an XHR. Let\u2019s break down that term: \"XML/HTTP\" request. Although the term itself is already showing its age (we don\u2019t use XML as much to send data over the web; JSON is used instead in most instances now), the second part of that term, HTTP, is critically important. HTTP stands for HyperTextTransfer Protocol and is the foundation of all communication on the web. Think of HTTP as the way in which all web based technologies must communicate with each other. You can analyze XHR for any website in the browser\u2019s network tab in Chrome developer tools. HTTP Error Codes Yes, XML/HTTP requests can be rejected by the server! If rejected, the web application server sends an HTTP response back to the client (the front-end). Possible HTTP error status codes are: 404 (not found) 403 (forbidden) 401 (not authorized) 500 (internal server error) 503 (service unavailable) There are many more HTTP status codes, and they are generally categorized by the first digit in the status code. Server and client are very common terms in computing. The \"server\" in full stack development typically refers to web application server, and the client refers to any device that is interacting with the server on the front-end. Common clients include laptop and desktop computers, mobile phones, GPS systems in cars, voice-driven devices like Amazon Alexa, Siri and Google Home, video game consoles, smart watches, and anything else that connects to a back-end. HTTP Success Codes All of the 200 level codes are generally positive status codes: 200 (ok) 201 (created) 202 (accepted), etc. By contrast, 400 level status codes generally indicate an issue with the request itself, and 500 level status codes generally indicate an error on the back-end. If the initial request has been accepted by the web application server, and there is a need to retrieve data related to the request, the web application server then queries a database or databases to get the information needed to send back to the user. The database sends the result of the query back to the web application server, and then the web application server usually formats the data into a format to be sent back to the front-end. JSON (JavaScript Object Notation) is a very common format currently used to send data to clients (the front-end). 200 level codes are positive, 400 level codes are issues and 500 level codes are errors. The Angular / NEST flow As an example, we can think of using TypeScript, a superset of JavaScript, to be building a full stack app called TS Flights that allows users to search for plane flights. The app will also have a page that allows you as an admin to enter new flights to show up in future searches. On the front-end we will be using Angular. On the back-end we will be using NestJS. For something like searching for a flight or adding a new flight into the database, our Angular front-end app will make requests to our NestJS back-end using XHR. If the request is rejected, it will return a negative HTTP status code back to Angular. If the request is accepted, it will then proceed to do the work that it was sent to do...which may include getting all of the flights from New York to Paris or something of that nature. If the request was accepted and includes a database call, NestJS will make a database query to our database, get the result, and if that database query is a success, return the JSON response to our Angular app with a 200 level status code. Our Angular app will then use HTML and CSS to make the response pretty so that our users can see all of the flights to Paris on their phone or computer. You should be able to see with this flow that the user initiates the process on the client, the request goes back to the server, does its work, and then ends up returning back to the client for the end of the process. Request/response cycles can be incredibly complex, but this very simple flow is the beginning of understanding the volleys between the front and the back end.","title":"General"},{"location":"fullstack/#the-concept-of-web-stacks","text":"Often you will hear programmers referring to various stacks in web development. In the last several years we have seen the proliferation of many stacks, including: MEAN (Mongo, Express, Angular and Node) LAMP (Linux, Apache, MySQL and PHP) Python-Django Ruby on Rails .NET It\u2019s important to understand that these stacks are constantly being invented, reinvented, iterated upon, and mixed with other stacks. The MEAN stack evolved into the PEAN or NEAP stack when some developers started switching back to using Postgresql instead of Mongo for the database resource related to that particular stack. Stack is not a technical term. It is a loose term and can be very fluid and sometimes even subjective. It is important, however, to be able to articulate which stacks you feel most comfortable with when you become a full stack developer. For example, a TypeScript based stack can use Angular and NestJS, one of the newer stacks in web development. JavaScript and TypeScript can be used in BOTH the front and the back-end of the stack.","title":"The Concept of Web Stacks"},{"location":"fullstack/#javascript-and-typescript-throughout-the-stack","text":"JavaScript became a popular full stack tool in 2009 after NodeJS was released. Prior to the release of NodeJS, JavaScript was seen as primarily a front-end only tool used for creating widgets, user activity on a page, DOM (web page structure) manipulation and other front-end only tasks. After NodeJS was released, JavaScript was seen as a great tool for creating back-ends and front-ends alike. TypeScript was released in 2012 by Microsoft because many JavaScript developers had expressed the desire for more structure and clear data types, especially for use in large scale applications. TypeScript has some features like static variable typing and interfaces that are present in well-respected legacy languages like Java and C#. TypeScript is a superset of JavaScript. What this means is that TypeScript is transpiled into JavaScript. It\u2019s literally translated into JavaScript code when it is compiled and before it is run. TypeScript is Translated into JavaScript. That\u2019s an important concept to remember! It therefore made logical sense, upon the release of NestJS, that TypeScript could be used throughout the entire web application stack just like JavaScript had been. One of the creators of Typescript was Microsoft employee Anders Hejlsberg, the creator of C#.","title":"JavaScript and TypeScript throughout the Stack"},{"location":"fullstack/#xhr","text":"The next concept to understand is the request / response nature of full stack applications. In a restaurant, the food request comes from the dining room, or the front-end. The customer makes a request to the kitchen. In web applications, this typically comes in the form of an XML/HTTP Request or an XHR. Let\u2019s break down that term: \"XML/HTTP\" request. Although the term itself is already showing its age (we don\u2019t use XML as much to send data over the web; JSON is used instead in most instances now), the second part of that term, HTTP, is critically important. HTTP stands for HyperTextTransfer Protocol and is the foundation of all communication on the web. Think of HTTP as the way in which all web based technologies must communicate with each other. You can analyze XHR for any website in the browser\u2019s network tab in Chrome developer tools.","title":"XHR"},{"location":"fullstack/#http-error-codes","text":"Yes, XML/HTTP requests can be rejected by the server! If rejected, the web application server sends an HTTP response back to the client (the front-end). Possible HTTP error status codes are: 404 (not found) 403 (forbidden) 401 (not authorized) 500 (internal server error) 503 (service unavailable) There are many more HTTP status codes, and they are generally categorized by the first digit in the status code. Server and client are very common terms in computing. The \"server\" in full stack development typically refers to web application server, and the client refers to any device that is interacting with the server on the front-end. Common clients include laptop and desktop computers, mobile phones, GPS systems in cars, voice-driven devices like Amazon Alexa, Siri and Google Home, video game consoles, smart watches, and anything else that connects to a back-end.","title":"HTTP Error Codes"},{"location":"fullstack/#http-success-codes","text":"All of the 200 level codes are generally positive status codes: 200 (ok) 201 (created) 202 (accepted), etc. By contrast, 400 level status codes generally indicate an issue with the request itself, and 500 level status codes generally indicate an error on the back-end. If the initial request has been accepted by the web application server, and there is a need to retrieve data related to the request, the web application server then queries a database or databases to get the information needed to send back to the user. The database sends the result of the query back to the web application server, and then the web application server usually formats the data into a format to be sent back to the front-end. JSON (JavaScript Object Notation) is a very common format currently used to send data to clients (the front-end). 200 level codes are positive, 400 level codes are issues and 500 level codes are errors.","title":"HTTP Success Codes"},{"location":"fullstack/#the-angular-nest-flow","text":"As an example, we can think of using TypeScript, a superset of JavaScript, to be building a full stack app called TS Flights that allows users to search for plane flights. The app will also have a page that allows you as an admin to enter new flights to show up in future searches. On the front-end we will be using Angular. On the back-end we will be using NestJS. For something like searching for a flight or adding a new flight into the database, our Angular front-end app will make requests to our NestJS back-end using XHR. If the request is rejected, it will return a negative HTTP status code back to Angular. If the request is accepted, it will then proceed to do the work that it was sent to do...which may include getting all of the flights from New York to Paris or something of that nature. If the request was accepted and includes a database call, NestJS will make a database query to our database, get the result, and if that database query is a success, return the JSON response to our Angular app with a 200 level status code. Our Angular app will then use HTML and CSS to make the response pretty so that our users can see all of the flights to Paris on their phone or computer. You should be able to see with this flow that the user initiates the process on the client, the request goes back to the server, does its work, and then ends up returning back to the client for the end of the process. Request/response cycles can be incredibly complex, but this very simple flow is the beginning of understanding the volleys between the front and the back end.","title":"The Angular / NEST flow"},{"location":"js_ECMAScript/","text":"What is ECMAScript? ECMAScript (often abbreviated ES) is the standardized specification that defines the core of the JavaScript language. It is maintained by ECMA International through the TC39 committee . JavaScript, along with other languages like JScript and ActionScript, is based on the ECMAScript standard to ensure consistent behavior across different environments. A Brief History of ECMAScript Versions Version Year Highlights ES1 1997 First official edition. ES2 1998 Editorial updates for ISO/IEC standards. ES3 1999 Regular expressions, try/catch , new control statements. ES4 Cancelled Too ambitious; replaced by a more incremental approach. ES5 2009 strict mode , JSON , getters/setters, array extras ( forEach , map , filter , etc.). ES5.1 2011 Minor corrections to align with ISO standards. ES6 (ES2015) 2015 Major update: classes, modules, let , const , promises, template literals, arrow functions. ES7 (ES2016) 2016 Array.includes() , exponentiation operator ( ** ). ES8 (ES2017) 2017 async/await , Object.values() , Object.entries() , padStart() , padEnd() . ES9 (ES2018) 2018 Asynchronous iteration ( for await...of ), object rest/spread, new regex features. ES10 (ES2019) 2019 Array.flat() , flatMap() , Object.fromEntries() , trimStart() , trimEnd() . ES11 (ES2020) 2020 Optional chaining ( ?. ), nullish coalescing ( ?? ), Promise.allSettled() , globalThis , BigInt. ES12 (ES2021) 2021 Logical assignment operators ( &&= , ||= , ??= ), numeric separators, Promise.any() . ES13 (ES2022) 2022 Top-level await , class static blocks, .at() method, error cause. ES14 (ES2023) 2023 toSorted() , toReversed() , toSpliced() , with() , findLast() , findLastIndex() . ES15 (ES2024) 2024 Set methods ( union , intersection , difference ), Array.groupBy() , iterator helpers. Detailed Version-by-Version Breakdown ECMAScript 1 (1997) First standardized version of JavaScript. Basic syntax and types were defined. ECMAScript 2 (1998) Editorial updates for international standardization. No major new features. ECMAScript 3 (1999) Introduced: Regular expressions try...catch error handling do...while , switch , new control structures Became the widely adopted baseline version for years. ECMAScript 4 (Cancelled) Proposed major changes (like classes, modules, type annotations), but deemed too ambitious and abandoned. ECMAScript 5 (2009) Important modernizations: Strict Mode ( \"use strict\" ) JSON support ( JSON.parse() , JSON.stringify() ) Getters and setters Array methods: forEach() , map() , filter() , reduce() , some() , every() Object methods: Object.create() , Object.defineProperty() ECMAScript 5.1 (2011) Small corrections and clarifications. ECMAScript 6 (2015) \u2014 A Major Milestone Key Features: Feature Description let , const Block-scoped variable declarations. Arrow Functions Concise anonymous functions ( (a) => a * 2 ). Template Literals Embedded expressions inside strings. Classes Native syntax for OOP. Destructuring Unpacking values from arrays/objects. Default Parameters Default values in function parameters. Rest/Spread Syntax Expand/collect elements using ... . Promises Native support for asynchronous workflows. Modules import / export syntax for modular JavaScript. Map , Set , WeakMap , WeakSet New data structures. Symbols New primitive for unique object keys. Iterators and Generators Build custom iterable sequences. ECMAScript 7\u201315 (2016\u20132024): Yearly Improvements ECMAScript 2016 (ES7) Array.prototype.includes() Exponentiation operator ( ** ) ECMAScript 2017 (ES8) async/await for asynchronous code. Object.entries() , Object.values() String padding: padStart() , padEnd() SharedArrayBuffer , Atomics for low-level memory handling. ECMAScript 2018 (ES9) Object Rest/Spread ( {...obj} ) Asynchronous iteration ( for await...of ) New RegExp features: named capture groups, lookbehind. ECMAScript 2019 (ES10) Array.flat() , Array.flatMap() Object.fromEntries() String trimStart() , trimEnd() Optional catch binding ( catch {} without error param) ECMAScript 2020 (ES11) Optional Chaining ( a?.b ) Nullish Coalescing ( a ?? b ) Promise.allSettled() globalThis Dynamic import() BigInt ECMAScript 2021 (ES12) Logical assignment operators ( &&= , ||= , ??= ) Numeric separators ( 1_000_000 ) Promise.any() WeakRef and FinalizationRegistry (advanced memory control) ECMAScript 2022 (ES13) Top-level await Class static initialization blocks .at() method for arrays/strings ( array.at(-1) ) Error.cause ECMAScript 2023 (ES14) Immutable array methods: toSorted() toReversed() toSpliced() with() New find methods: findLast() findLastIndex() ECMAScript 2024 (ES15) New Set methods : union() , intersection() , difference() , symmetricDifference() Array.groupBy() : Groups elements by a callback function. Iterator Helpers : Methods like map() , filter() , take() , drop() on iterators. Symbols as WeakMap keys : Symbols can now be used as keys in WeakMap/WeakSet. Conclusion From the humble beginnings of ES1 to the rich feature set of ES15 (2024) , ECMAScript continues to evolve and power JavaScript development across browsers, servers, and beyond. Keeping up with these changes ensures developers write modern, robust, efficient code that leverages the best features of the language.","title":"ECMAScript"},{"location":"js_ECMAScript/#what-is-ecmascript","text":"ECMAScript (often abbreviated ES) is the standardized specification that defines the core of the JavaScript language. It is maintained by ECMA International through the TC39 committee . JavaScript, along with other languages like JScript and ActionScript, is based on the ECMAScript standard to ensure consistent behavior across different environments.","title":"What is ECMAScript?"},{"location":"js_ECMAScript/#a-brief-history-of-ecmascript-versions","text":"Version Year Highlights ES1 1997 First official edition. ES2 1998 Editorial updates for ISO/IEC standards. ES3 1999 Regular expressions, try/catch , new control statements. ES4 Cancelled Too ambitious; replaced by a more incremental approach. ES5 2009 strict mode , JSON , getters/setters, array extras ( forEach , map , filter , etc.). ES5.1 2011 Minor corrections to align with ISO standards. ES6 (ES2015) 2015 Major update: classes, modules, let , const , promises, template literals, arrow functions. ES7 (ES2016) 2016 Array.includes() , exponentiation operator ( ** ). ES8 (ES2017) 2017 async/await , Object.values() , Object.entries() , padStart() , padEnd() . ES9 (ES2018) 2018 Asynchronous iteration ( for await...of ), object rest/spread, new regex features. ES10 (ES2019) 2019 Array.flat() , flatMap() , Object.fromEntries() , trimStart() , trimEnd() . ES11 (ES2020) 2020 Optional chaining ( ?. ), nullish coalescing ( ?? ), Promise.allSettled() , globalThis , BigInt. ES12 (ES2021) 2021 Logical assignment operators ( &&= , ||= , ??= ), numeric separators, Promise.any() . ES13 (ES2022) 2022 Top-level await , class static blocks, .at() method, error cause. ES14 (ES2023) 2023 toSorted() , toReversed() , toSpliced() , with() , findLast() , findLastIndex() . ES15 (ES2024) 2024 Set methods ( union , intersection , difference ), Array.groupBy() , iterator helpers.","title":"A Brief History of ECMAScript Versions"},{"location":"js_ECMAScript/#detailed-version-by-version-breakdown","text":"","title":"Detailed Version-by-Version Breakdown"},{"location":"js_ECMAScript/#ecmascript-1-1997","text":"First standardized version of JavaScript. Basic syntax and types were defined.","title":"ECMAScript 1 (1997)"},{"location":"js_ECMAScript/#ecmascript-2-1998","text":"Editorial updates for international standardization. No major new features.","title":"ECMAScript 2 (1998)"},{"location":"js_ECMAScript/#ecmascript-3-1999","text":"Introduced: Regular expressions try...catch error handling do...while , switch , new control structures Became the widely adopted baseline version for years.","title":"ECMAScript 3 (1999)"},{"location":"js_ECMAScript/#ecmascript-4-cancelled","text":"Proposed major changes (like classes, modules, type annotations), but deemed too ambitious and abandoned.","title":"ECMAScript 4 (Cancelled)"},{"location":"js_ECMAScript/#ecmascript-5-2009","text":"Important modernizations: Strict Mode ( \"use strict\" ) JSON support ( JSON.parse() , JSON.stringify() ) Getters and setters Array methods: forEach() , map() , filter() , reduce() , some() , every() Object methods: Object.create() , Object.defineProperty()","title":"ECMAScript 5 (2009)"},{"location":"js_ECMAScript/#ecmascript-51-2011","text":"Small corrections and clarifications.","title":"ECMAScript 5.1 (2011)"},{"location":"js_ECMAScript/#ecmascript-6-2015-a-major-milestone","text":"Key Features: Feature Description let , const Block-scoped variable declarations. Arrow Functions Concise anonymous functions ( (a) => a * 2 ). Template Literals Embedded expressions inside strings. Classes Native syntax for OOP. Destructuring Unpacking values from arrays/objects. Default Parameters Default values in function parameters. Rest/Spread Syntax Expand/collect elements using ... . Promises Native support for asynchronous workflows. Modules import / export syntax for modular JavaScript. Map , Set , WeakMap , WeakSet New data structures. Symbols New primitive for unique object keys. Iterators and Generators Build custom iterable sequences.","title":"ECMAScript 6 (2015) \u2014 A Major Milestone"},{"location":"js_ECMAScript/#ecmascript-715-20162024-yearly-improvements","text":"","title":"ECMAScript 7\u201315 (2016\u20132024): Yearly Improvements"},{"location":"js_ECMAScript/#ecmascript-2016-es7","text":"Array.prototype.includes() Exponentiation operator ( ** )","title":"ECMAScript 2016 (ES7)"},{"location":"js_ECMAScript/#ecmascript-2017-es8","text":"async/await for asynchronous code. Object.entries() , Object.values() String padding: padStart() , padEnd() SharedArrayBuffer , Atomics for low-level memory handling.","title":"ECMAScript 2017 (ES8)"},{"location":"js_ECMAScript/#ecmascript-2018-es9","text":"Object Rest/Spread ( {...obj} ) Asynchronous iteration ( for await...of ) New RegExp features: named capture groups, lookbehind.","title":"ECMAScript 2018 (ES9)"},{"location":"js_ECMAScript/#ecmascript-2019-es10","text":"Array.flat() , Array.flatMap() Object.fromEntries() String trimStart() , trimEnd() Optional catch binding ( catch {} without error param)","title":"ECMAScript 2019 (ES10)"},{"location":"js_ECMAScript/#ecmascript-2020-es11","text":"Optional Chaining ( a?.b ) Nullish Coalescing ( a ?? b ) Promise.allSettled() globalThis Dynamic import() BigInt","title":"ECMAScript 2020 (ES11)"},{"location":"js_ECMAScript/#ecmascript-2021-es12","text":"Logical assignment operators ( &&= , ||= , ??= ) Numeric separators ( 1_000_000 ) Promise.any() WeakRef and FinalizationRegistry (advanced memory control)","title":"ECMAScript 2021 (ES12)"},{"location":"js_ECMAScript/#ecmascript-2022-es13","text":"Top-level await Class static initialization blocks .at() method for arrays/strings ( array.at(-1) ) Error.cause","title":"ECMAScript 2022 (ES13)"},{"location":"js_ECMAScript/#ecmascript-2023-es14","text":"Immutable array methods: toSorted() toReversed() toSpliced() with() New find methods: findLast() findLastIndex()","title":"ECMAScript 2023 (ES14)"},{"location":"js_ECMAScript/#ecmascript-2024-es15","text":"New Set methods : union() , intersection() , difference() , symmetricDifference() Array.groupBy() : Groups elements by a callback function. Iterator Helpers : Methods like map() , filter() , take() , drop() on iterators. Symbols as WeakMap keys : Symbols can now be used as keys in WeakMap/WeakSet.","title":"ECMAScript 2024 (ES15)"},{"location":"js_ECMAScript/#conclusion","text":"From the humble beginnings of ES1 to the rich feature set of ES15 (2024) , ECMAScript continues to evolve and power JavaScript development across browsers, servers, and beyond. Keeping up with these changes ensures developers write modern, robust, efficient code that leverages the best features of the language.","title":"Conclusion"},{"location":"js_arrays/","text":"JavaScript Arrays An array is a special type of object. An array uses numbers to access its elements, and an object uses names to access its members. var courses = new Array ( 3 ); courses [ 0 ] = \"HTML\" ; courses [ 1 ] = \"CSS\" ; courses [ 2 ] = \"JS\" ; You refer to an array element by referring to the index number written in square brackets. This statement accesses the value of the first element in courses and changes the value of the second element. var courses = new Array ( \"HTML\" , \"CSS\" , \"JS\" ); var course = courses [ 0 ]; // HTML courses [ 1 ] = \"C++\" ; //Changes the second element JS[0] is the first element in an array. [1] is the second. Array indexes start with 0. Attempting to access an index outside of the array, returns the value undefined. JavaScript arrays are dynamic, so you can declare an array and not pass any arguments with the Array() constructor. You can then add the elements dynamically. var courses = new Array (); courses [ 0 ] = \"HTML\" ; courses [ 1 ] = \"CSS\" ; courses [ 2 ] = \"JS\" ; courses [ 3 ] = \"CS\" ; Array Literal For greater simplicity, readability, and execution speed, you can also declare arrays using the array literal syntax. var course = [ \"HTML\" , \"CSS\" ; \"JS\" ]; This results in the same array as the one created with the new Array() syntax. You can access and modify the elements of the array using the index number, as you did before. The array literal syntax is the recommended way to declare arrays. Arrays Properties and Methods The length property returns the number of elements of the array. The length property is always one more than the highest array index. If the array is empty, the length property returns 0. JavaScript's concat() method allows you to join arrays and create an entirely new array. var c1 = [ \"HTML\" , \"CSS\" ]; var c2 = [ \"JS\" , \"CS\" ]; var courses = c1 . concat ( c2 ); The concat operation does not affect the c1 and c2 arrays - it returns the resulting concatenation as a new array. Associative Arrays Remember that JavaScript does not support arrays with named indexes. In JavaScript, arrays always use numbered indexes. It is better to use an object when you want the index to be a string (text). Use an array when you want the index to be a number. If you use a named index, JavaScript will redefine the array to a standard object. Array Destructuring in ES6 The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables. ES6 has added a shorthand syntax for destructuring an array. The following example demonstrates how to unpack the elements of an array into distinct variables: let arr = [ '1' , '2' , '3' ]; let [ one , two , three ] = arr ; console . log ( one ); //1 console . log ( two ); //2 console . log ( three ); //3 We can also destructure an array returned by a function. let a = () => { return [ 1 , 2 , 3 ]; }; let [ one ,, two ] = a (); console . log ( one ); //1 console . log ( two ); //3 Notice that we left the second argument's place empty. The destructuring syntax also simplifies assignment and swapping values: let a , b , c = 4 , d = 8 ; [ a , b = 6 ] = [ 2 ]; // a=2, b=6 [ c , d ] = [ d , c ]; // c=8, d = 4 console . log ( a ); //2 console . log ( b ); //6 console . log ( c ); //4 console . log ( d ); //8 Array Element Finding The legacy way to find the first element of an array by its value and a rule was the following: [ 4 , 5 , 8 , 1 , 2 , 0 ]. filter ( function ( x ) { return x > 3 ; })[ 0 ]; The new syntax is cleaner and more robust: [ 4 , 5 , 8 , 1 , 2 , 0 ]. find ( x => x > 3 ); You can also get the index of the item above by using the findIndex() method: [ 4 , 5 , 8 , 1 , 2 , 0 ]. findIndex ( x => x > 3 ); ES6 Collections ES6 Map A Map object can be used to hold key/value pairs. A key or value in a map can be anything (objects and primitive values). The syntax new Map([iterable]) creates a Map object where iterable is an array or any other iterable object whose elements are arrays (with a key/value pair each). An Object is similar to Map but there are important differences that make using a Map preferable in certain cases: The keys can be any type including functions, objects, and any primitive. You can get the size of a Map. You can directly iterate over Map. Performance of the Map is better in scenarios involving frequent addition and removal of key/value pairs. The size property returns the number of key/value pairs in a map. let map = new Map ([[ 'k1' , 'v1' ],[ 'k2' , 'v2' ]]); Console . log ( map . size ); //2 Methods set(key, value) Adds a specified key/value pair to the map. If the specified key already exists, value corresponding to it is replaced with the specified value. get(key) Gets the value corresponding to a specified key in the map. If the specified key doesn't exist, undefined is returned. has(key) Returns true if a specified key exists in the map and false otherwise. delete(key) Deletes the key/value pair with a specified key from the map and returns true. Returns false if the element does not exist. clear() Removes all key/value pairs from map. keys() Returns an Iterator of keys in the map for each element. values() Returns an Iterator of values in the map for each element. entries() Returns an Iterator of array[key, value] in the map for each element. let map = new Map (); map . set ( 'k1' , 'v1' ). set ( 'k2' , 'v2' ); console . log ( map . get ( 'k1' )); // v1 console . log ( map . has ( 'k2' )); // true for ( let kv of map . entries ()){ console . log ( kv [ 0 ] + \" : \" + kv [ 1 ]); } // k1 : v1 // k2 : v2 The above example demonstrates some of the ES6 Map methods. Map supports different data types i.e. 1 and \"1\" are two different keys/values. ES6 Set A Set object can be used to hold unique values (no repetitions are allowed). A value in a set can be anything (objects and primitive values). The syntax new Set([iterable]) creates a Set object where iterable is an array or any other iterable object of values. The size property returns the number of distinct values in a set. For example: let set = new Set ([ 1 , 2 , 4 , 2 , 59 , 9 , 4 , 9 , 1 ]); console . log ( set . size ); //5 Methods add(value) Adds a new element with the given value to the Set. delete(value) Deletes a specified value from the set. has(value) Returns true if a specified value exists in the set and false otherwise. clear() Clears the set. values() Returns an Iterator of values in the set. let set = new Set (); set . add ( 5 ). add ( 9 ). add ( 59 ). add ( 9 ); console . log ( set . has ( 9 )); for ( let v of set . values ()){ console . log ( v ); } // 5 // 9 // 59 Set supports different data types i.e. 1 and \"1\" are two different values. NaN and undefined can also be stored in Set.","title":"Arrays n Collections"},{"location":"js_arrays/#javascript-arrays","text":"An array is a special type of object. An array uses numbers to access its elements, and an object uses names to access its members. var courses = new Array ( 3 ); courses [ 0 ] = \"HTML\" ; courses [ 1 ] = \"CSS\" ; courses [ 2 ] = \"JS\" ; You refer to an array element by referring to the index number written in square brackets. This statement accesses the value of the first element in courses and changes the value of the second element. var courses = new Array ( \"HTML\" , \"CSS\" , \"JS\" ); var course = courses [ 0 ]; // HTML courses [ 1 ] = \"C++\" ; //Changes the second element JS[0] is the first element in an array. [1] is the second. Array indexes start with 0. Attempting to access an index outside of the array, returns the value undefined. JavaScript arrays are dynamic, so you can declare an array and not pass any arguments with the Array() constructor. You can then add the elements dynamically. var courses = new Array (); courses [ 0 ] = \"HTML\" ; courses [ 1 ] = \"CSS\" ; courses [ 2 ] = \"JS\" ; courses [ 3 ] = \"CS\" ;","title":"JavaScript Arrays"},{"location":"js_arrays/#array-literal","text":"For greater simplicity, readability, and execution speed, you can also declare arrays using the array literal syntax. var course = [ \"HTML\" , \"CSS\" ; \"JS\" ]; This results in the same array as the one created with the new Array() syntax. You can access and modify the elements of the array using the index number, as you did before. The array literal syntax is the recommended way to declare arrays.","title":"Array Literal"},{"location":"js_arrays/#arrays-properties-and-methods","text":"The length property returns the number of elements of the array. The length property is always one more than the highest array index. If the array is empty, the length property returns 0. JavaScript's concat() method allows you to join arrays and create an entirely new array. var c1 = [ \"HTML\" , \"CSS\" ]; var c2 = [ \"JS\" , \"CS\" ]; var courses = c1 . concat ( c2 ); The concat operation does not affect the c1 and c2 arrays - it returns the resulting concatenation as a new array.","title":"Arrays Properties and Methods"},{"location":"js_arrays/#associative-arrays","text":"Remember that JavaScript does not support arrays with named indexes. In JavaScript, arrays always use numbered indexes. It is better to use an object when you want the index to be a string (text). Use an array when you want the index to be a number. If you use a named index, JavaScript will redefine the array to a standard object.","title":"Associative Arrays"},{"location":"js_arrays/#array-destructuring-in-es6","text":"The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables. ES6 has added a shorthand syntax for destructuring an array. The following example demonstrates how to unpack the elements of an array into distinct variables: let arr = [ '1' , '2' , '3' ]; let [ one , two , three ] = arr ; console . log ( one ); //1 console . log ( two ); //2 console . log ( three ); //3 We can also destructure an array returned by a function. let a = () => { return [ 1 , 2 , 3 ]; }; let [ one ,, two ] = a (); console . log ( one ); //1 console . log ( two ); //3 Notice that we left the second argument's place empty. The destructuring syntax also simplifies assignment and swapping values: let a , b , c = 4 , d = 8 ; [ a , b = 6 ] = [ 2 ]; // a=2, b=6 [ c , d ] = [ d , c ]; // c=8, d = 4 console . log ( a ); //2 console . log ( b ); //6 console . log ( c ); //4 console . log ( d ); //8","title":"Array Destructuring in ES6"},{"location":"js_arrays/#array-element-finding","text":"The legacy way to find the first element of an array by its value and a rule was the following: [ 4 , 5 , 8 , 1 , 2 , 0 ]. filter ( function ( x ) { return x > 3 ; })[ 0 ]; The new syntax is cleaner and more robust: [ 4 , 5 , 8 , 1 , 2 , 0 ]. find ( x => x > 3 ); You can also get the index of the item above by using the findIndex() method: [ 4 , 5 , 8 , 1 , 2 , 0 ]. findIndex ( x => x > 3 );","title":"Array Element Finding"},{"location":"js_arrays/#es6-collections","text":"","title":"ES6 Collections"},{"location":"js_arrays/#es6-map","text":"A Map object can be used to hold key/value pairs. A key or value in a map can be anything (objects and primitive values). The syntax new Map([iterable]) creates a Map object where iterable is an array or any other iterable object whose elements are arrays (with a key/value pair each). An Object is similar to Map but there are important differences that make using a Map preferable in certain cases: The keys can be any type including functions, objects, and any primitive. You can get the size of a Map. You can directly iterate over Map. Performance of the Map is better in scenarios involving frequent addition and removal of key/value pairs. The size property returns the number of key/value pairs in a map. let map = new Map ([[ 'k1' , 'v1' ],[ 'k2' , 'v2' ]]); Console . log ( map . size ); //2","title":"ES6 Map"},{"location":"js_arrays/#es6-set","text":"A Set object can be used to hold unique values (no repetitions are allowed). A value in a set can be anything (objects and primitive values). The syntax new Set([iterable]) creates a Set object where iterable is an array or any other iterable object of values. The size property returns the number of distinct values in a set. For example: let set = new Set ([ 1 , 2 , 4 , 2 , 59 , 9 , 4 , 9 , 1 ]); console . log ( set . size ); //5","title":"ES6 Set"},{"location":"js_classes/","text":"Classes in ES6 In this lesson we'll explain how to create a class that can be used to create multiple objects of the same structure. A class uses the keyword class and contains a constructor method for initializing. class Rectangle { constructor ( height , width ) { this . height = height ; this . width = width ; } } A declared class can then be used to create multiple objects using the keyword new. const square = new Rectangle ( 5 , 5 ); const poster = new Rectangle ( 2 , 3 ); Class Declarations are not hoisted while Function Declarations are. If you try to access your class before declaring it, ReferenceError will be returned. You can also define a class with a class expression, where the class can be named or unnamed. A named class looks like: var Square = class Rectangle { constructor ( height , width ){ this . height = height ; this . width = width } }; In the unnamed class expression, a variable is simply assigned the class definition: var Square = class { constructor ( height , width ){ this . height = height ; this . width = width } }; The constructor is a special method which is used for creating and initializing an object created with a class. There can be only one constructor in each class. Class Methods in ES6 ES6 introduced a shorthand that does not require the keyword function for a function assigned to a method's name. One type of class method is the prototype method, which is available to objects of the class. class Rectangle { constructor ( height , width ) { this . height = height ; this . width = width ; } get area (){ return this . calcArea (); } calcArea (){ return this . height * this . width } } const square = new Rectangle ( 5 , 5 ); console . log ( square . area ); //25 In the code above, area is a getter, calcArea is a method. Another type of method is the static method, which cannot be called through a class instance. Static methods are often used to create utility functions for an application. class Point { constructor ( x , y ){ this . x = x ; this . y = y ; } static distance ( a , b ) { const dx = a . x - b . x ; const dy = a . y - b . y ; return Math . hypot ( dx , dy ); } } const p1 = new Point ( 7 , 2 ); const p2 = new Point ( 3 , 8 ); console . log ( Point . distance ( p1 , p2 )); // 5.385164807134504 As you can see, the static distance method is called directly using the class name, without an object. Inheritance in ES6 The extends keyword is used in class declarations or class expressions to create a child of a class. The child inherits the properties and methods of the parent. class Animal { constructor ( name ){ this . name = name ; } speak (){ console . log ( this . name + 'makes noise' ); } } class Dog extends Animal { speak () { console . log ( this . name + 'Woof!' ); } } let dog = new Dog ( 'Sparky' ); dog . speak (); In the code above, the Dog class is a child of the Animal class, inheriting its properties and methods. If there is a constructor present in the subclass, it needs to first call super() before using this. Also, the super keyword is used to call parent's methods. For example, we can modify the program above to the following: class Animal { constructor ( name ){ this . name = name ; } speak (){ console . log ( this . name + 'makes noise' ); } } class Dog extends Animal { speak () { super . speak (); console . log ( this . name + 'Woof!' ); } } let dog = new Dog ( 'Sparky' ); dog . speak (); In the code above, the parent's speak() method is called using the super keyword.","title":"Classes"},{"location":"js_classes/#classes-in-es6","text":"In this lesson we'll explain how to create a class that can be used to create multiple objects of the same structure. A class uses the keyword class and contains a constructor method for initializing. class Rectangle { constructor ( height , width ) { this . height = height ; this . width = width ; } } A declared class can then be used to create multiple objects using the keyword new. const square = new Rectangle ( 5 , 5 ); const poster = new Rectangle ( 2 , 3 ); Class Declarations are not hoisted while Function Declarations are. If you try to access your class before declaring it, ReferenceError will be returned. You can also define a class with a class expression, where the class can be named or unnamed. A named class looks like: var Square = class Rectangle { constructor ( height , width ){ this . height = height ; this . width = width } }; In the unnamed class expression, a variable is simply assigned the class definition: var Square = class { constructor ( height , width ){ this . height = height ; this . width = width } }; The constructor is a special method which is used for creating and initializing an object created with a class. There can be only one constructor in each class.","title":"Classes in ES6"},{"location":"js_classes/#class-methods-in-es6","text":"ES6 introduced a shorthand that does not require the keyword function for a function assigned to a method's name. One type of class method is the prototype method, which is available to objects of the class. class Rectangle { constructor ( height , width ) { this . height = height ; this . width = width ; } get area (){ return this . calcArea (); } calcArea (){ return this . height * this . width } } const square = new Rectangle ( 5 , 5 ); console . log ( square . area ); //25 In the code above, area is a getter, calcArea is a method. Another type of method is the static method, which cannot be called through a class instance. Static methods are often used to create utility functions for an application. class Point { constructor ( x , y ){ this . x = x ; this . y = y ; } static distance ( a , b ) { const dx = a . x - b . x ; const dy = a . y - b . y ; return Math . hypot ( dx , dy ); } } const p1 = new Point ( 7 , 2 ); const p2 = new Point ( 3 , 8 ); console . log ( Point . distance ( p1 , p2 )); // 5.385164807134504 As you can see, the static distance method is called directly using the class name, without an object.","title":"Class Methods in ES6"},{"location":"js_classes/#inheritance-in-es6","text":"The extends keyword is used in class declarations or class expressions to create a child of a class. The child inherits the properties and methods of the parent. class Animal { constructor ( name ){ this . name = name ; } speak (){ console . log ( this . name + 'makes noise' ); } } class Dog extends Animal { speak () { console . log ( this . name + 'Woof!' ); } } let dog = new Dog ( 'Sparky' ); dog . speak (); In the code above, the Dog class is a child of the Animal class, inheriting its properties and methods. If there is a constructor present in the subclass, it needs to first call super() before using this. Also, the super keyword is used to call parent's methods. For example, we can modify the program above to the following: class Animal { constructor ( name ){ this . name = name ; } speak (){ console . log ( this . name + 'makes noise' ); } } class Dog extends Animal { speak () { super . speak (); console . log ( this . name + 'Woof!' ); } } let dog = new Dog ( 'Sparky' ); dog . speak (); In the code above, the parent's speak() method is called using the super keyword.","title":"Inheritance in ES6"},{"location":"js_controlflow/","text":"Control Flow For-Loops A for loop executes a set of statements a specific number of times. The init and increment statements may be left out, if not needed, but remember that the semicolons are mandatory. for (; ;) {} is an infinite loop. for ( var i = 0 ; i < 10 ; i ++ ) { //...; } While-Loops A while loop repeatedly executes a block of code as long as a given condition is true. var num = 1 ; while ( num < 6 ) { console . log ( num ); num ++ ; } Do-While Loops A do-while loop is similar to a while loop, except that a do-while loop is guaranteed to execute at least one time. var a = 0 ; do { console . log ( a ); a ++ ; } while ( a < 5 ); Loops since ES6 In JavaScript we commonly use the for loop to iterate over values in a list: let arr = [ 1 , 2 , 3 ]; for ( let k = 0 ; k < arr . length ; k ++ ){ console . log ( arr [ k ]); } For..in loop The for...in loop is intended for iterating over the enumerable keys of an object. For example: let obj = { a : 1 , b : 2 , c : 3 }; for ( let v in obj ){ console . log ( v ); } The for...in loop should NOT be used to iterate over arrays because, depending on the JavaScript engine, it could iterate in an arbitrary order. Also, the iterating variable is a string, not a number, so if you try to do any math with the variable, you'll be performing string concatenation instead of addition. For...of loop ES6 introduces the new for...of loop, which creates a loop iterating over iterable objects. For example: let list = [ \"x\" , \"y\" , \"z\" ]; for ( let val of list ){ console . log ( val ); } During each iteration the val variable is assigned the corresponding element in the list. The for...of loop works for other iterable objects as well, including strings for ( let val of \"Hello\" ){ console . log ( val ); } The for...of loop also works on the newly introduced collections (Map, Set, WeakMap, and WeakSet). Conditionals The general form of the if statement is: if ( x == 3 ) { //.... } else if ( x == 0 ) { //.... } else { //.... } Use relational operators (Comparison Operators) to evaluate conditions. They only work when they\u2019re comparing the same data type; numbers with numbers, strings with strings. In addition to the less than (<) and greater than (>) operators, the following operators are available: >=, <=, ==(Equal to), !=(Not Equal to), ===(Identical, Equal and same type), !==(Not identical). Remember, that an if can have zero or more else if's and they must come before the last else, which is optional. Once an else if succeeds, none of the remaining else if's or else clause will be tested. The switch statement provides a more elegant way to test a variable for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each switch case. The default code executes when none of the cases matches the switch expression. // Or using a switch: switch ( x ) { case 3 : // ... break ; case 0 : // ... break ; default : // ... break ; } Break and Continue When the break statement is encountered inside a loop, the loop is immediately terminated and the program execution moves on to the next statement following the loop body. If you are using nested loops (i.e., one loop inside another loop), the break statement will stop the execution of the innermost loop and start executing the next line of code after the block. The continue statement is similar to the break statement, but instead of terminating the loop entirely, it skips the current iteration of the loop and continues with the next iteration. for ( var i = 0 ; i < 10 ; i ++ ) { if ( i % 2 == 0 ) continue ; if ( i == 6 ) break ; console . log ( i ); } Iterators & Generators Symbol.iterator is the default iterator for an object. The for...of loops are based on this type of iterator. In the example below, we will see how we should implement it and how generator functions are used. Example: let myIterableObj = { [ Symbol . iterator ] : function * () { yield 1 ; yield 2 ; yield 3 ; ... console . log ([... myIterableObj ]); // [1, 2, 3] First, we create an object, and use the Symbol.iterator and generator function to fill it with some values. In the second line of the code, we use a * with the function keyword. It's called a generator function (or gen function). For example, here is a simple case of how gen functions can be useful: function * idMaker (){ let index = 0 ; while ( index < 5 ) { yield index ++ ; } } var gen = idMaker (); console . log ( gen . next (). value ); // 0 We can exit and re-enter generator functions later. Their variable bindings (context) will be saved across re-entrances. They are a very powerful tool for asynchronous programming, especially when combined with Promises. They can also be useful for creating loops with special requirements. We can nest generator functions inside each other to create more complex structures and pass them arguments while we are calling them. The example below will show a useful case of how we can use generator functions and Symbol.iterators together. Example: const arr = [ '0' , '1' , '4' , 'a' , '9' , 'c' , '16' ]; const my_obj = { [ Symbol . iterator ] : function * () { for ( let index of arr ){ yield ` ${ index } ` ; } } }; const all = [... my_obj ] . map ( i => parseInt ( i , 10 )) . map ( Math . sqrt ) . filter (( i ) => i < 5 ) . reduce (( i , d ) => i + d ); console . log ( all ); // 3.1622776601683795 We create an object of 7 elements by using Symbol.iterator and generator functions. In the second part, we assign our object to a constant all. At the end, we print its value.","title":"Control Flow"},{"location":"js_controlflow/#control-flow","text":"","title":"Control Flow"},{"location":"js_controlflow/#for-loops","text":"A for loop executes a set of statements a specific number of times. The init and increment statements may be left out, if not needed, but remember that the semicolons are mandatory. for (; ;) {} is an infinite loop. for ( var i = 0 ; i < 10 ; i ++ ) { //...; }","title":"For-Loops"},{"location":"js_controlflow/#while-loops","text":"A while loop repeatedly executes a block of code as long as a given condition is true. var num = 1 ; while ( num < 6 ) { console . log ( num ); num ++ ; }","title":"While-Loops"},{"location":"js_controlflow/#do-while-loops","text":"A do-while loop is similar to a while loop, except that a do-while loop is guaranteed to execute at least one time. var a = 0 ; do { console . log ( a ); a ++ ; } while ( a < 5 );","title":"Do-While Loops"},{"location":"js_controlflow/#loops-since-es6","text":"In JavaScript we commonly use the for loop to iterate over values in a list: let arr = [ 1 , 2 , 3 ]; for ( let k = 0 ; k < arr . length ; k ++ ){ console . log ( arr [ k ]); }","title":"Loops since ES6"},{"location":"js_controlflow/#forin-loop","text":"The for...in loop is intended for iterating over the enumerable keys of an object. For example: let obj = { a : 1 , b : 2 , c : 3 }; for ( let v in obj ){ console . log ( v ); } The for...in loop should NOT be used to iterate over arrays because, depending on the JavaScript engine, it could iterate in an arbitrary order. Also, the iterating variable is a string, not a number, so if you try to do any math with the variable, you'll be performing string concatenation instead of addition.","title":"For..in loop"},{"location":"js_controlflow/#forof-loop","text":"ES6 introduces the new for...of loop, which creates a loop iterating over iterable objects. For example: let list = [ \"x\" , \"y\" , \"z\" ]; for ( let val of list ){ console . log ( val ); } During each iteration the val variable is assigned the corresponding element in the list. The for...of loop works for other iterable objects as well, including strings for ( let val of \"Hello\" ){ console . log ( val ); } The for...of loop also works on the newly introduced collections (Map, Set, WeakMap, and WeakSet).","title":"For...of loop"},{"location":"js_controlflow/#conditionals","text":"The general form of the if statement is: if ( x == 3 ) { //.... } else if ( x == 0 ) { //.... } else { //.... } Use relational operators (Comparison Operators) to evaluate conditions. They only work when they\u2019re comparing the same data type; numbers with numbers, strings with strings. In addition to the less than (<) and greater than (>) operators, the following operators are available: >=, <=, ==(Equal to), !=(Not Equal to), ===(Identical, Equal and same type), !==(Not identical). Remember, that an if can have zero or more else if's and they must come before the last else, which is optional. Once an else if succeeds, none of the remaining else if's or else clause will be tested. The switch statement provides a more elegant way to test a variable for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each switch case. The default code executes when none of the cases matches the switch expression. // Or using a switch: switch ( x ) { case 3 : // ... break ; case 0 : // ... break ; default : // ... break ; }","title":"Conditionals"},{"location":"js_controlflow/#break-and-continue","text":"When the break statement is encountered inside a loop, the loop is immediately terminated and the program execution moves on to the next statement following the loop body. If you are using nested loops (i.e., one loop inside another loop), the break statement will stop the execution of the innermost loop and start executing the next line of code after the block. The continue statement is similar to the break statement, but instead of terminating the loop entirely, it skips the current iteration of the loop and continues with the next iteration. for ( var i = 0 ; i < 10 ; i ++ ) { if ( i % 2 == 0 ) continue ; if ( i == 6 ) break ; console . log ( i ); }","title":"Break and Continue"},{"location":"js_controlflow/#iterators-generators","text":"Symbol.iterator is the default iterator for an object. The for...of loops are based on this type of iterator. In the example below, we will see how we should implement it and how generator functions are used. Example: let myIterableObj = { [ Symbol . iterator ] : function * () { yield 1 ; yield 2 ; yield 3 ; ... console . log ([... myIterableObj ]); // [1, 2, 3] First, we create an object, and use the Symbol.iterator and generator function to fill it with some values. In the second line of the code, we use a * with the function keyword. It's called a generator function (or gen function). For example, here is a simple case of how gen functions can be useful: function * idMaker (){ let index = 0 ; while ( index < 5 ) { yield index ++ ; } } var gen = idMaker (); console . log ( gen . next (). value ); // 0 We can exit and re-enter generator functions later. Their variable bindings (context) will be saved across re-entrances. They are a very powerful tool for asynchronous programming, especially when combined with Promises. They can also be useful for creating loops with special requirements. We can nest generator functions inside each other to create more complex structures and pass them arguments while we are calling them. The example below will show a useful case of how we can use generator functions and Symbol.iterators together. Example: const arr = [ '0' , '1' , '4' , 'a' , '9' , 'c' , '16' ]; const my_obj = { [ Symbol . iterator ] : function * () { for ( let index of arr ){ yield ` ${ index } ` ; } } }; const all = [... my_obj ] . map ( i => parseInt ( i , 10 )) . map ( Math . sqrt ) . filter (( i ) => i < 5 ) . reduce (( i , d ) => i + d ); console . log ( all ); // 3.1622776601683795 We create an object of 7 elements by using Symbol.iterator and generator functions. In the second part, we assign our object to a constant all. At the end, we print its value.","title":"Iterators &amp; Generators"},{"location":"js_date/","text":"Date Object setInterval The setInterval() method calls a function or evaluates an expression at specified intervals (in milliseconds). It will continue calling the function until clearInterval() is called or the window is closed. function myAlert ()[ alert ( \"HI\" ); } setInterval ( myAlert , 3000 ); This will call the myAlert function every 3 seconds (1000 ms = 1 second). Write the name of the function without parentheses when passing it into the setInterval method. The Date object enables us to work with dates. A date consists of a year, a month, a day, an hour, a minute, a second, and milliseconds. Using new Date(), create a new date object with the current date and time var d = new Date (); //d stores the current date and time The other ways to initialize dates allow for the creation of new date objects from the specified date and time new Date(milliseconds) new Date(dateString) new Date(year, month, day, hours, minutes, seconds, milliseconds) JavaScript dates are calculated in milliseconds from 01 January, 1970 00:00:00 Universal Time (UTC). One day contains 86,400,000 millisecond. For example: //Fri Jan 02 1970 00:00:00 var d1 = new Date ( 86400000 ); //Fri Jan 02 2015 10:42:00 var d2 = new Date ( \"January 2, 2015 10:42:00\" ); //Sat Jun 11 1988 11:42:00 var d3 = new Date ( 88 , 5 , 11 , 11 , 42 , 0 , 0 ); JavaScript counts months from 0 to 11. January is 0, and December is 11. Date objects are static, rather than dynamic. The computer time is ticking, but date objects don't change, once created. When a Date object is created, a number of methods make it possible to perform operations on it. getMonth(), getDate(), getDay(),etc\u2026 var d = new Date (); var hours = d . getHours (); //hours equals to the current hour","title":"Dates"},{"location":"js_date/#date-object","text":"","title":"Date Object"},{"location":"js_dom/","text":"The DOM When you open any webpage in a browser, the HTML of the page is loaded and rendered visually on the screen. To accomplish that, the browser builds the Document Object Model of that page, which is an object oriented model of its logical structure. JavaScript can be used to manipulate the DOM of a page dynamically to add, delete and modify elements. The DOM represents a document as a tree structure. HTML elements become interrelated nodes in the tree. All those nodes in the tree have some kind of relations among each other. Nodes can have child nodes. Nodes on the same tree level are called siblings. For the example above: < html > has two children ( < head > , < body > ); < head > has one child ( < title > ) and one parent ( < html > ); < title > has one parent ( < head > ) and no children; < body > has two children ( < h1 > and < a > ) and one parent ( < html > ); It is important to understand the relationships between elements in an HTML document in order to be able to manipulate them with JavaScript. The document Object There is a predefined document object in JavaScript, which can be used to access all elements on the DOM. In other words, the document object is the owner (or root) of all objects in your webpage. So, if you want to access objects in an HTML page, you always start with accessing the document object. For example: document . body . innerHTML = \"Some text\" ; As body is an element of the DOM, we can access it using the document object and change the content of the innerHTML property. The innerHTML property can be used on almost all HTML elements to change its content. Selecting Elements All HTML elements are objects. And as we know every object has properties and methods. The document object has methods that allow you to select the desired HTML element. These three methods are the most commonly used for selecting HTML elements: //finds element by id document . getElementById ( id ) //finds elements by class name document . getElementsByClassName ( name ) //finds elements by tag name document . getElementsByTagName ( name ) In the example below, the getElementById method is used to select the element with id=\"demo\" and change its content: var elem = document . getElementById ( \"demo\" ); elem . innerHTML = \"Hello World!\" ; The example above assumes that the HTML contains an element with id=\"demo\", for example <div id=\"demo\"></div>. The getElementsByClassName() method returns a collection of all elements in the document with the specified class name. For example, if our HTML page contained three elements with class=\"demo\", the following code would return all those elements as an array: var arr = document . getElementsByClassName ( \"demo\" ); //accessing the second element arr [ 1 ]. innerHTML = \"Hi\" ; Similarly, the getElementsByTagName method returns all of the elements of the specified tag name as an array. The following example gets all paragraph elements of the page and changes their content: < p > hi < /p> < p > hello < /p> < p > hi < /p> < script > var arr = document . getElementsByTagName ( \"p\" ); for ( var x = 0 ; x < arr . length ; x ++ ) { arr [ x ]. innerHTML = \"Hi there\" ; } < /script> The script will result in the following HTML: < p > Hi there < /p> < p > Hi there < /p> < p > Hi there < /p> We used the length property of the array to loop through all the selected elements in the above example. Working with DOM Each element in the DOM has a set of properties and methods that provide information about their relationships in the DOM: element.childNodes returns an array of an element's child nodes. element.firstChild returns the first child node of an element. element.lastChild returns the last child node of an element. element.hasChildNodes returns true if an element has any child nodes, otherwise false. element.nextSibling returns the next node at the same tree level. element.previousSibling returns the previous node at the same tree level. element.parentNode returns the parent node of an element. We can, for example, select all child nodes of an element and change their content: < html > < body > < div id = \"demo\" > hi < p > hi </ p > < p > hello </ p > </ div > < script > var a = document . getElementsById ( \"demo\" ); var arr = a . childNodes ; for ( var x = 0 ; x < arr . length ; x ++ ) { arr [ x ]. innerHTML = \"Hi there\" ; } </ script > </ body > </ html > Changing Elements Once you have selected the element(s) you want to work with, you can change their attributes. As we have seen in the previous lessons, we can change the text content of an element using the innerHTML property. Similarly, we can change the attributes of elements. For example, we can change the src attribute of an image: < img id = \"myimg\" src = \"orange.png\" alt = \"\" /> < script > var el = document . getElementById ( \"myimg\" ); el . src = \"apple.png\" ; </ script > We can change the href attribute of a link: < a href = \"http://www.google.com/\" > Some URL </ a > < script > var el = document . getElementByTagName ( \"a\" ); el [ 0 ]. href = \"http://myurl.com/\" ; </ script > The style of HTML elements can also be changed using JavaScript. All style attributes can be accessed using the style object of the element. All CSS properties can be set and modified using JavaScript. Just remember, that you cannot use dashes (-) in the property names: these are replaced with camelCase versions, where the compound words begin with a capital letter. For example: the background-color property should be referred to as backgroundColor. < div id = \"demo\" style = \"width:200px\" > Some text </ div > < script > var el = document . getElementById ( \"demo\" ); el . style . color = \"6600FF\" ; el . style . width = \"100px\" ; </ script > Creating Elements Use the following methods to create new nodes: element.cloneNode() clones an element and returns the resulting node. document.createElement(element) creates a new element node. document.createTextNode(text) creates a new text node. var node = document.createTextNode(\"Some new text\"); This will create a new text node, but it will not appear in the document until you append it to an existing element with one of the following methods: element.appendChild(newNode) adds a new child node to an element as the last child node. element.insertBefore(node1, node2) inserts node1 as a child before node2. < div id = \"demo\" > Some Text </ div > < script > //create a new paragraph var p = document . createElement ( \"p\" ); var node = document . createTextNode ( \"Some new text\" ); //adding the text to paragraph p . appendChild ( node ); var div = document . getElementById ( \"demo\" ); //adding the paragraph to the div div . appendChild ( p ); </ script > To remove an HTML element, you must select the parent of the element and use the removeChild(node) method. An alternative way of achieving the same result would be the use of the parentNode property to get the parent of the element we want to remove: var child = document.getElementById(\"p1\"); child.parentNode.removeChild(child); To replace an HTML element, the element.replaceChild(newNode, oldNode) method is used. Animations To create an animation, we need to change the properties of an element at small intervals of time. We can achieve this by using the setInterval() method, which allows us to create a timer and call a function to change properties repeatedly at defined intervals (in milliseconds). For example: var t = setInterval ( move , 500 ); This code creates a timer that calls a move() function every 500 milliseconds. Now we need to define the move() function, that changes the position of the box. // starting position var pos = 0 ; //our box element var box = document . getElementById ( \"box\" ); function move () { pos += 1 ; box . style . left = pos + \"px\" ; //px = pixels } The move() function increments the left property of the box element by one each time it is called. The following code defines a timer that calls the move() function every 10 milliseconds: var t = setInterval ( move , 10 ); However, this makes our box move to the right forever. To stop the animation when the box reaches the end of the container, we add a simple check to the move() function and use the clearInterval() method to stop the timer. function move () { if ( pos >= 150 ) { clearInterval ( t ); } else { pos += 1 ; box . style . left = pos + \"px\" ; } } When the left attribute of the box reaches the value of 150, the box reaches the end of the container, based on a container width of 200 and a box width of 50.","title":"DOM"},{"location":"js_dom/#the-dom","text":"When you open any webpage in a browser, the HTML of the page is loaded and rendered visually on the screen. To accomplish that, the browser builds the Document Object Model of that page, which is an object oriented model of its logical structure. JavaScript can be used to manipulate the DOM of a page dynamically to add, delete and modify elements. The DOM represents a document as a tree structure. HTML elements become interrelated nodes in the tree. All those nodes in the tree have some kind of relations among each other. Nodes can have child nodes. Nodes on the same tree level are called siblings. For the example above: < html > has two children ( < head > , < body > ); < head > has one child ( < title > ) and one parent ( < html > ); < title > has one parent ( < head > ) and no children; < body > has two children ( < h1 > and < a > ) and one parent ( < html > ); It is important to understand the relationships between elements in an HTML document in order to be able to manipulate them with JavaScript.","title":"The DOM"},{"location":"js_dom/#the-document-object","text":"There is a predefined document object in JavaScript, which can be used to access all elements on the DOM. In other words, the document object is the owner (or root) of all objects in your webpage. So, if you want to access objects in an HTML page, you always start with accessing the document object. For example: document . body . innerHTML = \"Some text\" ; As body is an element of the DOM, we can access it using the document object and change the content of the innerHTML property. The innerHTML property can be used on almost all HTML elements to change its content.","title":"The document Object"},{"location":"js_dom/#selecting-elements","text":"All HTML elements are objects. And as we know every object has properties and methods. The document object has methods that allow you to select the desired HTML element. These three methods are the most commonly used for selecting HTML elements: //finds element by id document . getElementById ( id ) //finds elements by class name document . getElementsByClassName ( name ) //finds elements by tag name document . getElementsByTagName ( name ) In the example below, the getElementById method is used to select the element with id=\"demo\" and change its content: var elem = document . getElementById ( \"demo\" ); elem . innerHTML = \"Hello World!\" ; The example above assumes that the HTML contains an element with id=\"demo\", for example <div id=\"demo\"></div>. The getElementsByClassName() method returns a collection of all elements in the document with the specified class name. For example, if our HTML page contained three elements with class=\"demo\", the following code would return all those elements as an array: var arr = document . getElementsByClassName ( \"demo\" ); //accessing the second element arr [ 1 ]. innerHTML = \"Hi\" ; Similarly, the getElementsByTagName method returns all of the elements of the specified tag name as an array. The following example gets all paragraph elements of the page and changes their content: < p > hi < /p> < p > hello < /p> < p > hi < /p> < script > var arr = document . getElementsByTagName ( \"p\" ); for ( var x = 0 ; x < arr . length ; x ++ ) { arr [ x ]. innerHTML = \"Hi there\" ; } < /script> The script will result in the following HTML: < p > Hi there < /p> < p > Hi there < /p> < p > Hi there < /p> We used the length property of the array to loop through all the selected elements in the above example.","title":"Selecting Elements"},{"location":"js_dom/#working-with-dom","text":"Each element in the DOM has a set of properties and methods that provide information about their relationships in the DOM: element.childNodes returns an array of an element's child nodes. element.firstChild returns the first child node of an element. element.lastChild returns the last child node of an element. element.hasChildNodes returns true if an element has any child nodes, otherwise false. element.nextSibling returns the next node at the same tree level. element.previousSibling returns the previous node at the same tree level. element.parentNode returns the parent node of an element. We can, for example, select all child nodes of an element and change their content: < html > < body > < div id = \"demo\" > hi < p > hi </ p > < p > hello </ p > </ div > < script > var a = document . getElementsById ( \"demo\" ); var arr = a . childNodes ; for ( var x = 0 ; x < arr . length ; x ++ ) { arr [ x ]. innerHTML = \"Hi there\" ; } </ script > </ body > </ html >","title":"Working with DOM"},{"location":"js_dom/#changing-elements","text":"Once you have selected the element(s) you want to work with, you can change their attributes. As we have seen in the previous lessons, we can change the text content of an element using the innerHTML property. Similarly, we can change the attributes of elements. For example, we can change the src attribute of an image: < img id = \"myimg\" src = \"orange.png\" alt = \"\" /> < script > var el = document . getElementById ( \"myimg\" ); el . src = \"apple.png\" ; </ script > We can change the href attribute of a link: < a href = \"http://www.google.com/\" > Some URL </ a > < script > var el = document . getElementByTagName ( \"a\" ); el [ 0 ]. href = \"http://myurl.com/\" ; </ script > The style of HTML elements can also be changed using JavaScript. All style attributes can be accessed using the style object of the element. All CSS properties can be set and modified using JavaScript. Just remember, that you cannot use dashes (-) in the property names: these are replaced with camelCase versions, where the compound words begin with a capital letter. For example: the background-color property should be referred to as backgroundColor. < div id = \"demo\" style = \"width:200px\" > Some text </ div > < script > var el = document . getElementById ( \"demo\" ); el . style . color = \"6600FF\" ; el . style . width = \"100px\" ; </ script >","title":"Changing Elements"},{"location":"js_dom/#creating-elements","text":"Use the following methods to create new nodes: element.cloneNode() clones an element and returns the resulting node. document.createElement(element) creates a new element node. document.createTextNode(text) creates a new text node. var node = document.createTextNode(\"Some new text\"); This will create a new text node, but it will not appear in the document until you append it to an existing element with one of the following methods: element.appendChild(newNode) adds a new child node to an element as the last child node. element.insertBefore(node1, node2) inserts node1 as a child before node2. < div id = \"demo\" > Some Text </ div > < script > //create a new paragraph var p = document . createElement ( \"p\" ); var node = document . createTextNode ( \"Some new text\" ); //adding the text to paragraph p . appendChild ( node ); var div = document . getElementById ( \"demo\" ); //adding the paragraph to the div div . appendChild ( p ); </ script > To remove an HTML element, you must select the parent of the element and use the removeChild(node) method. An alternative way of achieving the same result would be the use of the parentNode property to get the parent of the element we want to remove: var child = document.getElementById(\"p1\"); child.parentNode.removeChild(child); To replace an HTML element, the element.replaceChild(newNode, oldNode) method is used.","title":"Creating Elements"},{"location":"js_dom/#animations","text":"To create an animation, we need to change the properties of an element at small intervals of time. We can achieve this by using the setInterval() method, which allows us to create a timer and call a function to change properties repeatedly at defined intervals (in milliseconds). For example: var t = setInterval ( move , 500 ); This code creates a timer that calls a move() function every 500 milliseconds. Now we need to define the move() function, that changes the position of the box. // starting position var pos = 0 ; //our box element var box = document . getElementById ( \"box\" ); function move () { pos += 1 ; box . style . left = pos + \"px\" ; //px = pixels } The move() function increments the left property of the box element by one each time it is called. The following code defines a timer that calls the move() function every 10 milliseconds: var t = setInterval ( move , 10 ); However, this makes our box move to the right forever. To stop the animation when the box reaches the end of the container, we add a simple check to the move() function and use the clearInterval() method to stop the timer. function move () { if ( pos >= 150 ) { clearInterval ( t ); } else { pos += 1 ; box . style . left = pos + \"px\" ; } } When the left attribute of the box reaches the value of 150, the box reaches the end of the container, based on a container width of 200 and a box width of 50.","title":"Animations"},{"location":"js_event/","text":"Events You can write JavaScript code that executes when an event occurs, such as when a user clicks an HTML element, moves the mouse, or submits a form. When an event occurs on a target element, a handler function is executed. Common HTML events: Event Description onchange An HTML element has been changed onclick The user clicks an HTML element onmouseover The user moves the mouse over an HTML element onmouseout The user moves the mouse away from an HTML element onkeydown The user pushes a keyboard key onload The browser has finished loading the page Corresponding events can be added to HTML elements as attributes. For example: < p onclick = \"someFunc()\" > some text </ p > Handling Events Let's display an alert popup when the user clicks a specified button: < button onclick = \"show()\" > Click Me </ button > < script > function show (){ alert ( \"hello\" ); } </ script > Event handlers can be assigned to elements. For example: var x=document.getElementById(\"demo\"); x.onclick = function () { document.body.innerHTML = Date(); } The onload and onunload events are triggered when the user enters or leaves the page. These can be useful when performing actions after the page is loaded. < body onload = \"doSomething()\" > Similarly, the window.onload event can be used to run code after the whole page is loaded. window . onload \u200b = function () { \u200b //some code } The onchange event is mostly used on textboxes. The event handler gets called when the text inside the textbox changes and focus is lost from the element. Event Listeners The addEventListener() method attaches an event handler to an element without overwriting existing event handlers. You can add many event handlers to one element. You can also add many event handlers of the same type to one element, i.e., two \"click\" events. element . addEventListener ( event , function , useCapture ); The first parameter is the event's type (like \"click\" or \"mousedown\"). The second parameter is the function we want to call when the event occurs. The third parameter is a Boolean value specifying whether to use event bubbling or event capturing. This parameter is optional, and will be described in the next lesson. Note that you don't use the \"on\" prefix for this event; use \"click\" instead of \"onclick\". Example: element . addEventListener ( \"click\" , myFunction ); element . addEventListener ( \"mouseover\" , myFunction ); function myFunction () { alert ( \"Hello World!\" ); } This adds two event listeners to the element. We can remove one of the listeners: element . removeEventListener ( \"mouseover\" , myFunction ); Internet Explorer version 8 and lower do not support the addEventListener() and removeEventListener() methods. However, you can use the document.attachEvent() method to attach event handlers in Internet Explorer. Event Propagation There are two ways of event propagation in the HTML DOM: bubbling and capturing. Event propagation allows for the definition of the element order when an event occurs. If you have a <p> element inside a <div> element, and the user clicks on the <p> element, which element's \"click\" event should be handled first? In bubbling, the innermost element's event is handled first and then the outer element's event is handled. The <p> element's click event is handled first, followed by the <div> element's click event. In capturing, the outermost element's event is handled first and then the inner. The <div> element's click event is handled first, followed by the <p> element's click event. Capturing goes down the DOM. Bubbling goes up the DOM. Capturing vs. Bubbling The addEventListener() method allows you to specify the propagation type with the \"useCapture\" parameter. addEventListener ( event , function , useCapture ) The default value is false, which means the bubbling propagation is used; when the value is set to true, the event uses the capturing propagation. //Capturing propagation elem1 . addEventListener ( \"click\" , myFunction , true ); //Bubbling propagation elem2 . addEventListener ( \"click\" , myFunction , false ); This is particularly useful when you have the same event handled for multiple elements in the DOM hierarchy. Image Slider - Example Now we need to handle the Next and Prev button clicks and call the corresponding functions to change the image. js HTML: < div > < button onclick = \"prev()\" > Prev </ button > < img id = \"slider\" src = \"http://www.mysite.com/uploads/slider/1.jpg\" width = \"200px\" height = \"100px\" /> < button onclick = \"next()\" > Next </ button > </ div > //JS: var images = [ \"http://www.mysite.com/uploads/slider/1.jpg\" , \"http://www.mysite.com/uploads/slider/2.jpg\" , \"http://www.mysite.com/uploads/slider/3.jpg\" ]; var num = 0 ; function next () { var slider = document . getElementById ( \"slider\" ); num ++ ; if ( num >= images . length ){ num = 0 ; } slider . src = images [ num ]; } function prev (){ var slider = document . getElementById ( \"slider\" ); num -- ; if ( num < 0 ){ num = images . length - 1 ; } slider . src = images [ num ]; } Form Validation HTML5 adds some attributes that allow form validation. For example, the required attribute can be added to an input field to make it mandatory to fill in. More complex form validation can be done using JavaScript. The form element has an onsubmit event that can be handled to perform validation. For example, let's create a form with two inputs and one button. The text in both fields should be the same and not blank to pass the validation. < form onsubmit = \"return validate()\" method = \"post\" > Number: < input type = \"text\" name = \"num1\" id = \"num1\" /> < br /> Repeat: < input type = \"text\" name = \"num2\" id = \"num2\" /> < br /> < input type = \"submit\" value = \"Submit\" /> </ form > function validate () { var n1 = document . getElementById ( \"num1\" ); var n2 = document . getElementById ( \"num2\" ); if ( n1 . value != \"\" && n2 . value != \"\" ){ if ( n1 . value == n2 . value ){ return true ; } } alert ( \"The values should be equal and not blank\" ); return false ; } The form will not get submitted if its onsubmit event returns false","title":"Events"},{"location":"js_event/#events","text":"You can write JavaScript code that executes when an event occurs, such as when a user clicks an HTML element, moves the mouse, or submits a form. When an event occurs on a target element, a handler function is executed. Common HTML events: Event Description onchange An HTML element has been changed onclick The user clicks an HTML element onmouseover The user moves the mouse over an HTML element onmouseout The user moves the mouse away from an HTML element onkeydown The user pushes a keyboard key onload The browser has finished loading the page Corresponding events can be added to HTML elements as attributes. For example: < p onclick = \"someFunc()\" > some text </ p >","title":"Events"},{"location":"js_event/#handling-events","text":"Let's display an alert popup when the user clicks a specified button: < button onclick = \"show()\" > Click Me </ button > < script > function show (){ alert ( \"hello\" ); } </ script > Event handlers can be assigned to elements. For example: var x=document.getElementById(\"demo\"); x.onclick = function () { document.body.innerHTML = Date(); } The onload and onunload events are triggered when the user enters or leaves the page. These can be useful when performing actions after the page is loaded. < body onload = \"doSomething()\" > Similarly, the window.onload event can be used to run code after the whole page is loaded. window . onload \u200b = function () { \u200b //some code } The onchange event is mostly used on textboxes. The event handler gets called when the text inside the textbox changes and focus is lost from the element.","title":"Handling Events"},{"location":"js_event/#event-listeners","text":"The addEventListener() method attaches an event handler to an element without overwriting existing event handlers. You can add many event handlers to one element. You can also add many event handlers of the same type to one element, i.e., two \"click\" events. element . addEventListener ( event , function , useCapture ); The first parameter is the event's type (like \"click\" or \"mousedown\"). The second parameter is the function we want to call when the event occurs. The third parameter is a Boolean value specifying whether to use event bubbling or event capturing. This parameter is optional, and will be described in the next lesson. Note that you don't use the \"on\" prefix for this event; use \"click\" instead of \"onclick\". Example: element . addEventListener ( \"click\" , myFunction ); element . addEventListener ( \"mouseover\" , myFunction ); function myFunction () { alert ( \"Hello World!\" ); } This adds two event listeners to the element. We can remove one of the listeners: element . removeEventListener ( \"mouseover\" , myFunction ); Internet Explorer version 8 and lower do not support the addEventListener() and removeEventListener() methods. However, you can use the document.attachEvent() method to attach event handlers in Internet Explorer.","title":"Event Listeners"},{"location":"js_event/#event-propagation","text":"There are two ways of event propagation in the HTML DOM: bubbling and capturing. Event propagation allows for the definition of the element order when an event occurs. If you have a <p> element inside a <div> element, and the user clicks on the <p> element, which element's \"click\" event should be handled first? In bubbling, the innermost element's event is handled first and then the outer element's event is handled. The <p> element's click event is handled first, followed by the <div> element's click event. In capturing, the outermost element's event is handled first and then the inner. The <div> element's click event is handled first, followed by the <p> element's click event. Capturing goes down the DOM. Bubbling goes up the DOM.","title":"Event Propagation"},{"location":"js_event/#capturing-vs-bubbling","text":"The addEventListener() method allows you to specify the propagation type with the \"useCapture\" parameter. addEventListener ( event , function , useCapture ) The default value is false, which means the bubbling propagation is used; when the value is set to true, the event uses the capturing propagation. //Capturing propagation elem1 . addEventListener ( \"click\" , myFunction , true ); //Bubbling propagation elem2 . addEventListener ( \"click\" , myFunction , false ); This is particularly useful when you have the same event handled for multiple elements in the DOM hierarchy.","title":"Capturing vs. Bubbling"},{"location":"js_event/#image-slider-example","text":"Now we need to handle the Next and Prev button clicks and call the corresponding functions to change the image. js HTML: < div > < button onclick = \"prev()\" > Prev </ button > < img id = \"slider\" src = \"http://www.mysite.com/uploads/slider/1.jpg\" width = \"200px\" height = \"100px\" /> < button onclick = \"next()\" > Next </ button > </ div > //JS: var images = [ \"http://www.mysite.com/uploads/slider/1.jpg\" , \"http://www.mysite.com/uploads/slider/2.jpg\" , \"http://www.mysite.com/uploads/slider/3.jpg\" ]; var num = 0 ; function next () { var slider = document . getElementById ( \"slider\" ); num ++ ; if ( num >= images . length ){ num = 0 ; } slider . src = images [ num ]; } function prev (){ var slider = document . getElementById ( \"slider\" ); num -- ; if ( num < 0 ){ num = images . length - 1 ; } slider . src = images [ num ]; }","title":"Image Slider - Example"},{"location":"js_event/#form-validation","text":"HTML5 adds some attributes that allow form validation. For example, the required attribute can be added to an input field to make it mandatory to fill in. More complex form validation can be done using JavaScript. The form element has an onsubmit event that can be handled to perform validation. For example, let's create a form with two inputs and one button. The text in both fields should be the same and not blank to pass the validation. < form onsubmit = \"return validate()\" method = \"post\" > Number: < input type = \"text\" name = \"num1\" id = \"num1\" /> < br /> Repeat: < input type = \"text\" name = \"num2\" id = \"num2\" /> < br /> < input type = \"submit\" value = \"Submit\" /> </ form > function validate () { var n1 = document . getElementById ( \"num1\" ); var n2 = document . getElementById ( \"num2\" ); if ( n1 . value != \"\" && n2 . value != \"\" ){ if ( n1 . value == n2 . value ){ return true ; } } alert ( \"The values should be equal and not blank\" ); return false ; } The form will not get submitted if its onsubmit event returns false","title":"Form Validation"},{"location":"js_exceptions/","text":"Exceptions An exception is a problem that occurs during program execution. Exceptions cause abnormal termination of the program. An exception can occur for many different reasons. Some examples: A user has entered invalid data. A file that needs to be opened cannot be found. A network connection has been lost in the middle of communications. Insufficient memory and other issues related to physical resources. JavaScript (similar to Java and C#) provides a flexible mechanism called the try-catch statement to handle exceptions so that a program won't crash when an error occurs. The code that might generate an exception is placed in the try block. If an exception occurs, the catch blocks is executed without stopping the program. The type of exception you want to catch appears in parentheses following the keyword catch. We use the general Exception type to handle all kinds of exceptions. We can also use the exception object e to access the exception details, such as the original error message (e.Message): A single try block can contain multiple catch blocks that handle different exceptions separately. Exception handling is particularly useful when dealing with user input. try { nonExistentFunction (); } catch ( error ) { console . error ( error ); // expected output: ReferenceError: nonExistentFunction is not defined // Note - error messages will vary depending on browser } An optional finally block can be used after the catch blocks. The finally block is used to execute a given set of statements, whether an exception is thrown or not. try { try_statements } catch ( exception_var ) { catch_statements } finally { finally_statements } try { myroutine (); // may throw three types of exceptions } catch ( e ) { if ( e instanceof TypeError ) { // statements to handle TypeError exceptions } else if ( e instanceof RangeError ) { // statements to handle RangeError exceptions } else if ( e instanceof EvalError ) { // statements to handle EvalError exceptions } else { // statements to handle any unspecified exceptions logMyErrors ( e ); // pass exception object to error handler } } throw The throw keyword allows you to manually generate exceptions from your methods. A common use case for this is to only catch (and silence) a small subset of expected errors, and then re-throw the error in other cases: try { myRoutine (); } catch ( e ) { if ( e instanceof RangeError ) { // statements to handle this very common expected error } else { throw e ; // re-throw the error unchanged } }","title":"Exceptions"},{"location":"js_exceptions/#exceptions","text":"An exception is a problem that occurs during program execution. Exceptions cause abnormal termination of the program. An exception can occur for many different reasons. Some examples: A user has entered invalid data. A file that needs to be opened cannot be found. A network connection has been lost in the middle of communications. Insufficient memory and other issues related to physical resources. JavaScript (similar to Java and C#) provides a flexible mechanism called the try-catch statement to handle exceptions so that a program won't crash when an error occurs. The code that might generate an exception is placed in the try block. If an exception occurs, the catch blocks is executed without stopping the program. The type of exception you want to catch appears in parentheses following the keyword catch. We use the general Exception type to handle all kinds of exceptions. We can also use the exception object e to access the exception details, such as the original error message (e.Message): A single try block can contain multiple catch blocks that handle different exceptions separately. Exception handling is particularly useful when dealing with user input. try { nonExistentFunction (); } catch ( error ) { console . error ( error ); // expected output: ReferenceError: nonExistentFunction is not defined // Note - error messages will vary depending on browser } An optional finally block can be used after the catch blocks. The finally block is used to execute a given set of statements, whether an exception is thrown or not. try { try_statements } catch ( exception_var ) { catch_statements } finally { finally_statements } try { myroutine (); // may throw three types of exceptions } catch ( e ) { if ( e instanceof TypeError ) { // statements to handle TypeError exceptions } else if ( e instanceof RangeError ) { // statements to handle RangeError exceptions } else if ( e instanceof EvalError ) { // statements to handle EvalError exceptions } else { // statements to handle any unspecified exceptions logMyErrors ( e ); // pass exception object to error handler } }","title":"Exceptions"},{"location":"js_exceptions/#throw","text":"The throw keyword allows you to manually generate exceptions from your methods. A common use case for this is to only catch (and silence) a small subset of expected errors, and then re-throw the error in other cases: try { myRoutine (); } catch ( e ) { if ( e instanceof RangeError ) { // statements to handle this very common expected error } else { throw e ; // re-throw the error unchanged } }","title":"throw"},{"location":"js_func/","text":"JavaScript Functions Functions define behavior. A function is a collection of statements that are grouped together to perform an operation. You can define your own functions to perform your desired tasks. Functions have many advantages, including: Reusable code. Easy to test. Modifications to a function do not affect the calling program. One function can accept many different inputs. To define a JavaScript function, use the function keyword, followed by a name, followed by a set of parentheses (). The code to be executed by the function is placed inside curly brackets {}. function name () { //code to be executed } Function names can contain letters, digits, underscores, and dollar signs (same rules as variables). Parameters should be given names, which are separated by commas within the parentheses. If you pass more arguments than are defined, they will be assigned to an array called arguments. They can be used like this: arguments[0], arguments[1], etc. After defining the function, you can call it as many times as needed. JavaScript functions do not check the number of arguments received. If a function is called with missing arguments (fewer than declared), the missing values are set to undefined, which indicates that a variable has not been assigned a value. //Function definition function sayHello ( name , age ) { console . log ( name + \" is \" + age + \" years old.\" ); } //Function use sayHello ( \"Cassie\" , 20 ); A function can have an optional return statement. It is used to return a value from the function. This statement is useful when making calculations that require a result. When JavaScript reaches a return statement, the function stops executing. //Function definition function myFunction ( a , b ) { return a * b ; } //Function use var res = myFunction ( 3 , 2 ); If you do not return anything from a function, it will return undefined. JavaScript Objects JavaScript variables are containers for data values. Objects are variables too, but they can contain many values. Think of an object as a list of values that are written as name:value pairs, with the names and the values separated by colons. You can access object properties in two ways. objectName . propertyName //or objectName [ 'propertyName' ] var person = { name : \"John\" , age : 31 , favColor : \"green\" , height : 183 }; var x = person . age ; //the same as: var y = person [ 'age' ]; These values are called properties. JavaScript objects are containers for named values. JavaScript's built-in length property is used to count the number of characters in a property or string. An object method is a property that contains a function definition. Use the following syntax to access an object method. objectName . methodName () Methods are functions that are stored as object properties. Constructor Function Sometimes, we need to set an \"object type\" that can be used to create a number of objects of a single type. The standard way to create an \"object type\" is to use an object constructor function. function person ( name , age , color ) { this . name = name ; this . age = age ; this . favColor = color ; } The above function (person) is an object constructor, which takes parameters and assigns them to the object properties. The this keyword refers to the current object. Note that this is not a variable. It is a keyword, and its value cannot be changed. Once you have an object constructor, you can use the new keyword to create new objects of the same type. var p1 = new person ( \"Amid\" , 42 , \"purple\" ); var p2 = new person ( \"Jessie\" , 39 , \"red\" ); p1 and p2 are now objects of the person type. Their properties are assigned to the corresponding values. Object Initialization Use the object literal or initializer syntax to create single objects. var John = { name : \"John\" , age : 25 }; var James = { name : \"James\" , age : 21 }; Objects consist of properties, which are used to describe an object. Values of object properties can either contain primitive data types or other objects. Object Methods Methods are functions that are stored as object properties. Use the following syntax to create an object method: methodName = function () { code lines } Access an object method using the following syntax: objectName . methodName () A method is a function, belonging to an object. It can be referenced using the this keyword. The this keyword is used as a reference to the current object, meaning that you can access the objects properties and methods using it. Defining methods is done inside the constructor function. function person ( name , age , color ) { this . name = name ; this . age = age ; this . changeName = function ( name ){ this . name = name ; } } var p = new person ( \"David\" , 21 ); p . changeName ( \"Jhon\" ); You can also define the function outside of the constructor function and associate it with the object. function person ( name , age ) { this . name = name ; this . age = age ; this . yearOfBirth = bornYear ; } function bornYear () { return 2016 - this . age ; } var p = new person ( \"David\" , 21 ); console . log ( p . yearOfBirth ()); Note that it's not necessary to write the function's parentheses when assigning it to an object. Call the method by the property name you specified in the constructor function, rather than the function name. Functions in ECMAScript 6 Prior to ES6, a JavaScript function was defined like this: function add ( x , y ){ var sum = x + y ; console . log ( sum ); } ES6 introduces a new syntax for writing functions. The same function from above can be written as: const add = ( x , y ) => { let sum = x + y ; console . log ( sum ); } This new syntax is quite handy when you just need a simple function with one argument. You can skip typing function and return, as well as some parentheses and braces. For example: const greet = x => \"Welcome \" + x ; console . log ( greet ( \"John\" )); The code above defines a function named greet that has one argument and returns a message. If there are no parameters, an empty pair of parentheses should be used, as in const x = () => alert ( \"Hi\" ); The syntax is very useful for inline functions. For example, let's say we have an array, and for each element of the array we need to execute a function. We use the forEach method of the array to call a function for each element: var arr = [ 2 , 3 , 7 , 8 ]; arr . forEach ( function ( el ) { console . log ( el * 2 ); }); However, in ES6, the code above can be rewritten as following: var arr = [ 2 , 3 , 7 , 8 ]; arr . forEach ( v => { console . log ( v * 2 ); }); Default Parameters in ES6 In ES6, we can put the default values right in the signature of the functions. function test ( a , b = 3 , c = 42 ){ return a + b + c ; } console . log ( test ( 5 )); //50 And here's an example of an arrow function with default parameters: const test = ( a , b = 3 , c = 42 ) => { return a + b + c ; } console . log ( test ( 5 )); //50 Default value expressions are evaluated at function call time from left to right. This also means that default expressions can use the values of previously-filled parameters. ES6 Rest Parameters Prior to ES6, if we wanted to pass a variable number of arguments to a function, we could use the arguments object, an array-like object, to access the parameters passed to the function. For example, let's write a function that checks if an array contains all the arguments passed: function containsAll ( arr ){ for ( let k = 1 ; k < arguments . length ; k ++ ){ let num = arguments [ k ]; if ( arr . indexOf ( num ) === - 1 ){ return false ; } } return true ; } let x = [ 2 , 4 , 6 , 7 ]; console . log ( containsAll ( x , 2 , 4 , 7 )); console . log ( containsAll ( x , 6 , 4 , 9 )); We can pass any number of arguments to the function and access it using the arguments object. While this does the job, ES6 provides a more readable syntax to achieve variable number of parameters by using a rest parameter: function containsAll ( arr , ... nums ){ for ( let num of nums ){ if ( arr . indexOf ( num ) === - 1 ){ return false ; } } return true ; } The ...nums parameter is called a rest parameter. It takes all the \"extra\" arguments passed to the function. The three dots (...) are called the Spread operator. Only the last parameter of a function may be marked as a rest parameter. If there are no extra arguments, the rest parameter will simply be an empty array; the rest parameter will never be undefined.","title":"Functions"},{"location":"js_func/#javascript-functions","text":"Functions define behavior. A function is a collection of statements that are grouped together to perform an operation. You can define your own functions to perform your desired tasks. Functions have many advantages, including: Reusable code. Easy to test. Modifications to a function do not affect the calling program. One function can accept many different inputs. To define a JavaScript function, use the function keyword, followed by a name, followed by a set of parentheses (). The code to be executed by the function is placed inside curly brackets {}. function name () { //code to be executed } Function names can contain letters, digits, underscores, and dollar signs (same rules as variables). Parameters should be given names, which are separated by commas within the parentheses. If you pass more arguments than are defined, they will be assigned to an array called arguments. They can be used like this: arguments[0], arguments[1], etc. After defining the function, you can call it as many times as needed. JavaScript functions do not check the number of arguments received. If a function is called with missing arguments (fewer than declared), the missing values are set to undefined, which indicates that a variable has not been assigned a value. //Function definition function sayHello ( name , age ) { console . log ( name + \" is \" + age + \" years old.\" ); } //Function use sayHello ( \"Cassie\" , 20 ); A function can have an optional return statement. It is used to return a value from the function. This statement is useful when making calculations that require a result. When JavaScript reaches a return statement, the function stops executing. //Function definition function myFunction ( a , b ) { return a * b ; } //Function use var res = myFunction ( 3 , 2 ); If you do not return anything from a function, it will return undefined.","title":"JavaScript Functions"},{"location":"js_func/#javascript-objects","text":"JavaScript variables are containers for data values. Objects are variables too, but they can contain many values. Think of an object as a list of values that are written as name:value pairs, with the names and the values separated by colons. You can access object properties in two ways. objectName . propertyName //or objectName [ 'propertyName' ] var person = { name : \"John\" , age : 31 , favColor : \"green\" , height : 183 }; var x = person . age ; //the same as: var y = person [ 'age' ]; These values are called properties. JavaScript objects are containers for named values. JavaScript's built-in length property is used to count the number of characters in a property or string. An object method is a property that contains a function definition. Use the following syntax to access an object method. objectName . methodName () Methods are functions that are stored as object properties.","title":"JavaScript Objects"},{"location":"js_func/#constructor-function","text":"Sometimes, we need to set an \"object type\" that can be used to create a number of objects of a single type. The standard way to create an \"object type\" is to use an object constructor function. function person ( name , age , color ) { this . name = name ; this . age = age ; this . favColor = color ; } The above function (person) is an object constructor, which takes parameters and assigns them to the object properties. The this keyword refers to the current object. Note that this is not a variable. It is a keyword, and its value cannot be changed. Once you have an object constructor, you can use the new keyword to create new objects of the same type. var p1 = new person ( \"Amid\" , 42 , \"purple\" ); var p2 = new person ( \"Jessie\" , 39 , \"red\" ); p1 and p2 are now objects of the person type. Their properties are assigned to the corresponding values.","title":"Constructor Function"},{"location":"js_func/#object-initialization","text":"Use the object literal or initializer syntax to create single objects. var John = { name : \"John\" , age : 25 }; var James = { name : \"James\" , age : 21 }; Objects consist of properties, which are used to describe an object. Values of object properties can either contain primitive data types or other objects.","title":"Object Initialization"},{"location":"js_func/#object-methods","text":"Methods are functions that are stored as object properties. Use the following syntax to create an object method: methodName = function () { code lines } Access an object method using the following syntax: objectName . methodName () A method is a function, belonging to an object. It can be referenced using the this keyword. The this keyword is used as a reference to the current object, meaning that you can access the objects properties and methods using it. Defining methods is done inside the constructor function. function person ( name , age , color ) { this . name = name ; this . age = age ; this . changeName = function ( name ){ this . name = name ; } } var p = new person ( \"David\" , 21 ); p . changeName ( \"Jhon\" ); You can also define the function outside of the constructor function and associate it with the object. function person ( name , age ) { this . name = name ; this . age = age ; this . yearOfBirth = bornYear ; } function bornYear () { return 2016 - this . age ; } var p = new person ( \"David\" , 21 ); console . log ( p . yearOfBirth ()); Note that it's not necessary to write the function's parentheses when assigning it to an object. Call the method by the property name you specified in the constructor function, rather than the function name.","title":"Object Methods"},{"location":"js_func/#functions-in-ecmascript-6","text":"Prior to ES6, a JavaScript function was defined like this: function add ( x , y ){ var sum = x + y ; console . log ( sum ); } ES6 introduces a new syntax for writing functions. The same function from above can be written as: const add = ( x , y ) => { let sum = x + y ; console . log ( sum ); } This new syntax is quite handy when you just need a simple function with one argument. You can skip typing function and return, as well as some parentheses and braces. For example: const greet = x => \"Welcome \" + x ; console . log ( greet ( \"John\" )); The code above defines a function named greet that has one argument and returns a message. If there are no parameters, an empty pair of parentheses should be used, as in const x = () => alert ( \"Hi\" ); The syntax is very useful for inline functions. For example, let's say we have an array, and for each element of the array we need to execute a function. We use the forEach method of the array to call a function for each element: var arr = [ 2 , 3 , 7 , 8 ]; arr . forEach ( function ( el ) { console . log ( el * 2 ); }); However, in ES6, the code above can be rewritten as following: var arr = [ 2 , 3 , 7 , 8 ]; arr . forEach ( v => { console . log ( v * 2 ); });","title":"Functions in ECMAScript 6"},{"location":"js_func/#default-parameters-in-es6","text":"In ES6, we can put the default values right in the signature of the functions. function test ( a , b = 3 , c = 42 ){ return a + b + c ; } console . log ( test ( 5 )); //50 And here's an example of an arrow function with default parameters: const test = ( a , b = 3 , c = 42 ) => { return a + b + c ; } console . log ( test ( 5 )); //50 Default value expressions are evaluated at function call time from left to right. This also means that default expressions can use the values of previously-filled parameters.","title":"Default Parameters in ES6"},{"location":"js_func/#es6-rest-parameters","text":"Prior to ES6, if we wanted to pass a variable number of arguments to a function, we could use the arguments object, an array-like object, to access the parameters passed to the function. For example, let's write a function that checks if an array contains all the arguments passed: function containsAll ( arr ){ for ( let k = 1 ; k < arguments . length ; k ++ ){ let num = arguments [ k ]; if ( arr . indexOf ( num ) === - 1 ){ return false ; } } return true ; } let x = [ 2 , 4 , 6 , 7 ]; console . log ( containsAll ( x , 2 , 4 , 7 )); console . log ( containsAll ( x , 6 , 4 , 9 )); We can pass any number of arguments to the function and access it using the arguments object. While this does the job, ES6 provides a more readable syntax to achieve variable number of parameters by using a rest parameter: function containsAll ( arr , ... nums ){ for ( let num of nums ){ if ( arr . indexOf ( num ) === - 1 ){ return false ; } } return true ; } The ...nums parameter is called a rest parameter. It takes all the \"extra\" arguments passed to the function. The three dots (...) are called the Spread operator. Only the last parameter of a function may be marked as a rest parameter. If there are no extra arguments, the rest parameter will simply be an empty array; the rest parameter will never be undefined.","title":"ES6 Rest Parameters"},{"location":"js_intro/","text":"String, Variables and Assignments Each statement in JavaScript must end with a semicolon (;) . A comment beginning with two slashes (//) is called a single-line comment. Comments that require multiple lines begin with / and end with / at the end of the comment block. // this is a single-line comment var x = 5 ; // a single-line comment after code /* This is also a comment spanning multiple lines */ JSDocs /** * This is a function. * * @param {string} n - A string param * @return {string} A good string * * @example * * foo('hello') */ function foo ( n ) { return n } Data Types Declaring a variable is as simple as using the keyword var. JavaScript variable names are case-sensitive. The first character of a variable name must be a letter, underscore (_), or a dollar sign ($) (Subsequent characters can be letters, digits, underscores, or dollar signs). The first character of a variable name can\u2019t be a number. Variable names can\u2019t include a mathematical or logical operator in their name. For instance, 2*something or this+that; Variable names can\u2019t contain spaces. You\u2019re not allowed to use any special symbols, like my#num, num%, etc. var x = 10 ; var y = 10.55 ; var name = \"John\" ; var isAlive = true ; var myNull = null ; var myUndefined = undefined ; Single or double quotes, it doesn\u2019t matter, so long as you\u2019re consistent with them. Like this: var name = 'John' ; var text = \"My name is John Smith\" ; You can use quotes inside a string, as long as they don't match the quotes enclosing the string itself. var name = 'John' ; var text = \"My name is 'John' \" ; You can get double quotes inside of double quotes using the escape character like this: \\\" or \\' inside of single quotes. If you start a string with a single quote, then you need to end it with a single quote too. This applies to double quotes. Otherwise, JavaScript will get confused. Booleans var isActive = true ; var isAlive = false ; The Boolean value of 0 (zero), null, undefined, empty string is false. Everything with a \"real\" value is true. First JavaScript Program On the web, JavaScript code lives inside the HTML document, and needs to be enclosed by and : <!doctype html> < html > < head > < meta charset = \"utf-8\" > < title > JavaScript Mastery </ title > </ head > < body > < h1 > JavaScript Mastery </ h1 > < script > document . write ( \"<h1>Hello World!</h1>\" ) console . log ( \"Hello Console!\" ) </ script > </ body > </ html > Variable Declaration Since ES6 we have three ways of declaring variables: var x = 5 ; let y = 5 ; const z = 5 ; The type of declaration used depends on the necessary scope. Scope is the fundamental concept in all programming languages that defines the visibility of a variable. var & let Unlike the var keyword, which defines a variable globally, or locally to an entire function regardless of block scope, let allows you to declare variables that are limited in scope to the block, statement, or expression in which they are used. if ( true ){ let name = 'Jack' ; } alert ( name ); //generates error In this case, the name variable is accessible only in the scope of the if statement because it was declared as let. To demonstrate the difference in scope between var and let, consider this example: function varTest (){ var x = 1 ; if ( true ){ var x = 2 ; // same variable console . log ( x ); // 2 } console . log ( x ); //2 } function letTest (){ let x = 1 ; if ( true ){ let x = 2 ; // different variable console . log ( x ); // 2 } console . log ( x ); //1 } varTest (); letTest (); One of the best uses for let is in loops: for ( let i = 0 ; i < 10 ; i ++ ){ console . log ( i ); } let is not subject to Variable Hoisting, which means that let declarations do not move to the top of the current execution context. const const variables have the same scope as variables declared using let. The difference is that const variables are immutable - they are not allowed to be reassigned. For example, the following generates an exception: const x = 5 ; x = 6 ; const is not subject to Variable Hoisting too, which means that const declarations do not move to the top of the current execution context. Also note that ES6 code will run only in browsers that support it. Older devices and browsers that do not support ES6 will return a syntax error. Template Literals in ES6 Template literals are a way to output variables in the string. Prior to ES6 we had to break the string, for example: var name = 'John' ; var text = 'My name is ' + name ; Now we can use template literals: var name = 'John' ; var text = `My name is ${ name } ` ; Notice that template literals are enclosed by the backtick ( ) character instead of double or single quotes. The ${expression} is a placeholder, and can include any expression, which will get evaluated and inserted into the template literal. let a = 8 ; let b = 3 ; let msg = `The sum is ${ a + b } !` ; console . log ( msg ); To escape a backtick in a template literal, put a backslash \\ before the backtick. Repeating Strings Before ES6 the following syntax was the correct way to repeat a string multiple times: console . log ( Array ( 3 + 1 ). join ( \"foo\" )); //foofoofoo With the new syntax, it becomes: console . log ( \"foo\" . repeat ( 3 )); //foofoofoo Searching Strings Before ES6 we only used the indexOf() method to find the position of the text in the string. For example: \"Hello World!\" . indexOf ( \"Wo\" ); \"Hello World!\" . indexOf ( \"Wo\" ) === 6 ; ES6 has replaced this with a version that has cleaner and more simplified syntax: \"Hello World!\" . startsWith ( \"He\" ); \"Hello World!\" . endsWith ( \"He\" ); \"Hello World!\" . includes ( \"He\" ); PopUp Boxes JavaScript offers three types of popup boxes, the Alert, Prompt, and Confirm boxes. Alert Box An alert box is used when you want to ensure that information gets through to the user. When an alert box pops up, the user must click OK to proceed. The alert function takes a single parameter, which is the text displayed in the popup box. To display line breaks within a popup box, use a backslash followed by the character n. alert ( \"Hello World!\\nBye\" ); Be careful when using alert boxes, as the user can continue using the page only after clicking OK. Prompt Box A prompt box is often used to have the user input a value before entering a page. When a prompt box pops up, the user will have to click either OK or Cancel to proceed after entering the input value. If the user clicks OK, the box returns the input value. If the user clicks Cancel, the box returns null. The prompt() method takes two parameters. The first is the label, which you want to display in the text box. The second is a default string to display in the text box (optional). var user = prompt ( \"Enter your name\" ); if ( user != null ) { alert ( \"Hello \" + user ); } else { alert ( \"Bye\" ); } When a prompt box pops up, the user will have to click either \"OK\" or \"Cancel\" to proceed after entering an input value. Do not overuse this method, because it prevents the user from accessing other parts of the page until the box is closed. Confirm Box A confirm box is often used to have the user verify or accept something. When a confirm box pops up, the user must click either OK or Cancel to proceed. If the user clicks OK, the box returns true. If the user clicks Cancel, the box returns false. The confirm() method takes a single parameter, which is the text displayed in the popup box. var result = confirm ( \"Want to exit?\" ); if ( result ) { alert ( \"Bye!\" ); } else { alert ( \"Continue\" ); }","title":"Intro"},{"location":"js_intro/#string-variables-and-assignments","text":"Each statement in JavaScript must end with a semicolon (;) . A comment beginning with two slashes (//) is called a single-line comment. Comments that require multiple lines begin with / and end with / at the end of the comment block. // this is a single-line comment var x = 5 ; // a single-line comment after code /* This is also a comment spanning multiple lines */","title":"String, Variables and Assignments"},{"location":"js_intro/#jsdocs","text":"/** * This is a function. * * @param {string} n - A string param * @return {string} A good string * * @example * * foo('hello') */ function foo ( n ) { return n }","title":"JSDocs"},{"location":"js_intro/#data-types","text":"Declaring a variable is as simple as using the keyword var. JavaScript variable names are case-sensitive. The first character of a variable name must be a letter, underscore (_), or a dollar sign ($) (Subsequent characters can be letters, digits, underscores, or dollar signs). The first character of a variable name can\u2019t be a number. Variable names can\u2019t include a mathematical or logical operator in their name. For instance, 2*something or this+that; Variable names can\u2019t contain spaces. You\u2019re not allowed to use any special symbols, like my#num, num%, etc. var x = 10 ; var y = 10.55 ; var name = \"John\" ; var isAlive = true ; var myNull = null ; var myUndefined = undefined ; Single or double quotes, it doesn\u2019t matter, so long as you\u2019re consistent with them. Like this: var name = 'John' ; var text = \"My name is John Smith\" ; You can use quotes inside a string, as long as they don't match the quotes enclosing the string itself. var name = 'John' ; var text = \"My name is 'John' \" ; You can get double quotes inside of double quotes using the escape character like this: \\\" or \\' inside of single quotes. If you start a string with a single quote, then you need to end it with a single quote too. This applies to double quotes. Otherwise, JavaScript will get confused.","title":"Data Types"},{"location":"js_intro/#booleans","text":"var isActive = true ; var isAlive = false ; The Boolean value of 0 (zero), null, undefined, empty string is false. Everything with a \"real\" value is true.","title":"Booleans"},{"location":"js_intro/#first-javascript-program","text":"On the web, JavaScript code lives inside the HTML document, and needs to be enclosed by and : <!doctype html> < html > < head > < meta charset = \"utf-8\" > < title > JavaScript Mastery </ title > </ head > < body > < h1 > JavaScript Mastery </ h1 > < script > document . write ( \"<h1>Hello World!</h1>\" ) console . log ( \"Hello Console!\" ) </ script > </ body > </ html >","title":"First JavaScript Program"},{"location":"js_intro/#variable-declaration","text":"Since ES6 we have three ways of declaring variables: var x = 5 ; let y = 5 ; const z = 5 ; The type of declaration used depends on the necessary scope. Scope is the fundamental concept in all programming languages that defines the visibility of a variable.","title":"Variable Declaration"},{"location":"js_intro/#var-let","text":"Unlike the var keyword, which defines a variable globally, or locally to an entire function regardless of block scope, let allows you to declare variables that are limited in scope to the block, statement, or expression in which they are used. if ( true ){ let name = 'Jack' ; } alert ( name ); //generates error In this case, the name variable is accessible only in the scope of the if statement because it was declared as let. To demonstrate the difference in scope between var and let, consider this example: function varTest (){ var x = 1 ; if ( true ){ var x = 2 ; // same variable console . log ( x ); // 2 } console . log ( x ); //2 } function letTest (){ let x = 1 ; if ( true ){ let x = 2 ; // different variable console . log ( x ); // 2 } console . log ( x ); //1 } varTest (); letTest (); One of the best uses for let is in loops: for ( let i = 0 ; i < 10 ; i ++ ){ console . log ( i ); } let is not subject to Variable Hoisting, which means that let declarations do not move to the top of the current execution context.","title":"var &amp; let"},{"location":"js_intro/#const","text":"const variables have the same scope as variables declared using let. The difference is that const variables are immutable - they are not allowed to be reassigned. For example, the following generates an exception: const x = 5 ; x = 6 ; const is not subject to Variable Hoisting too, which means that const declarations do not move to the top of the current execution context. Also note that ES6 code will run only in browsers that support it. Older devices and browsers that do not support ES6 will return a syntax error.","title":"const"},{"location":"js_intro/#template-literals-in-es6","text":"Template literals are a way to output variables in the string. Prior to ES6 we had to break the string, for example: var name = 'John' ; var text = 'My name is ' + name ; Now we can use template literals: var name = 'John' ; var text = `My name is ${ name } ` ; Notice that template literals are enclosed by the backtick ( ) character instead of double or single quotes. The ${expression} is a placeholder, and can include any expression, which will get evaluated and inserted into the template literal. let a = 8 ; let b = 3 ; let msg = `The sum is ${ a + b } !` ; console . log ( msg ); To escape a backtick in a template literal, put a backslash \\ before the backtick.","title":"Template Literals in ES6"},{"location":"js_intro/#repeating-strings","text":"Before ES6 the following syntax was the correct way to repeat a string multiple times: console . log ( Array ( 3 + 1 ). join ( \"foo\" )); //foofoofoo With the new syntax, it becomes: console . log ( \"foo\" . repeat ( 3 )); //foofoofoo","title":"Repeating Strings"},{"location":"js_intro/#searching-strings","text":"Before ES6 we only used the indexOf() method to find the position of the text in the string. For example: \"Hello World!\" . indexOf ( \"Wo\" ); \"Hello World!\" . indexOf ( \"Wo\" ) === 6 ; ES6 has replaced this with a version that has cleaner and more simplified syntax: \"Hello World!\" . startsWith ( \"He\" ); \"Hello World!\" . endsWith ( \"He\" ); \"Hello World!\" . includes ( \"He\" );","title":"Searching Strings"},{"location":"js_intro/#popup-boxes","text":"JavaScript offers three types of popup boxes, the Alert, Prompt, and Confirm boxes.","title":"PopUp Boxes"},{"location":"js_intro/#alert-box","text":"An alert box is used when you want to ensure that information gets through to the user. When an alert box pops up, the user must click OK to proceed. The alert function takes a single parameter, which is the text displayed in the popup box. To display line breaks within a popup box, use a backslash followed by the character n. alert ( \"Hello World!\\nBye\" ); Be careful when using alert boxes, as the user can continue using the page only after clicking OK.","title":"Alert Box"},{"location":"js_intro/#prompt-box","text":"A prompt box is often used to have the user input a value before entering a page. When a prompt box pops up, the user will have to click either OK or Cancel to proceed after entering the input value. If the user clicks OK, the box returns the input value. If the user clicks Cancel, the box returns null. The prompt() method takes two parameters. The first is the label, which you want to display in the text box. The second is a default string to display in the text box (optional). var user = prompt ( \"Enter your name\" ); if ( user != null ) { alert ( \"Hello \" + user ); } else { alert ( \"Bye\" ); } When a prompt box pops up, the user will have to click either \"OK\" or \"Cancel\" to proceed after entering an input value. Do not overuse this method, because it prevents the user from accessing other parts of the page until the box is closed.","title":"Prompt Box"},{"location":"js_intro/#confirm-box","text":"A confirm box is often used to have the user verify or accept something. When a confirm box pops up, the user must click either OK or Cancel to proceed. If the user clicks OK, the box returns true. If the user clicks Cancel, the box returns false. The confirm() method takes a single parameter, which is the text displayed in the popup box. var result = confirm ( \"Want to exit?\" ); if ( result ) { alert ( \"Bye!\" ); } else { alert ( \"Continue\" ); }","title":"Confirm Box"},{"location":"js_module/","text":"Modules It is a good practice to divide your related code into modules. Before ES6 there were some libraries which made this possible (e.g., RequireJS, CommonJS). ES6 is now supporting this feature natively. Considerations when using modules: The first consideration is maintainability. A module is independent of other modules, making improvements and expansion possible without any dependency on code in other modules. The second consideration is namespacing. In an earlier lesson, we talked about variables and scope. As you know, vars are globally declared, so it's common to have namespace pollution where unrelated variables are accessible all over our code. Modules solve this problem by creating a private space for variables. Another important consideration is reusability. When we write code that can be used in other projects, modules make it possible to easily reuse the code without having to rewrite it in a new project. Let's see how we should use modules in JS files. For Example: // lib/math.js export \u200b let sum = ( x , y ) => { return x + y ; } export \u200b let pi = 3.14 // app.j import * \u200b as math from \"lib/mat\" console . log ( `2p = + ${ math . sum ( math . pi , math . pi ) // 6.28","title":"Modules"},{"location":"js_module/#modules","text":"It is a good practice to divide your related code into modules. Before ES6 there were some libraries which made this possible (e.g., RequireJS, CommonJS). ES6 is now supporting this feature natively. Considerations when using modules: The first consideration is maintainability. A module is independent of other modules, making improvements and expansion possible without any dependency on code in other modules. The second consideration is namespacing. In an earlier lesson, we talked about variables and scope. As you know, vars are globally declared, so it's common to have namespace pollution where unrelated variables are accessible all over our code. Modules solve this problem by creating a private space for variables. Another important consideration is reusability. When we write code that can be used in other projects, modules make it possible to easily reuse the code without having to rewrite it in a new project. Let's see how we should use modules in JS files. For Example: // lib/math.js export \u200b let sum = ( x , y ) => { return x + y ; } export \u200b let pi = 3.14 // app.j import * \u200b as math from \"lib/mat\" console . log ( `2p = + ${ math . sum ( math . pi , math . pi ) // 6.28","title":"Modules"},{"location":"js_object/","text":"ES6 Objects JavaScript variables can be Object data types that contain many values called properties. An object can also have properties that are function definitions called methods for performing actions on the object. ES6 introduces shorthand notations and computed property names that make declaring and using objects easier to understand. The new method definition shorthand does not require the colon (:) or function keyword, as in the grow function of the tree object declaration: let tree = { height : 10 , color : 'green' , grow () { this . height += 2 ; } }; tree . grow (); console . log ( tree . height ); //12 You can also use a property value shorthand when initializing properties with a variable by the same name. For example, properties height and health are being initialized with variables named height and health let height = 5 ; let health = 100 ; let athlete = { height , health }; console . log ( athlete . height ); //5 console . log ( athlete . health ); //100 When creating an object by using duplicate property names, the last property will overwrite the prior ones of the same name. For Example: var a = { x : 1 , x : 2 , x : 3 , x : 4 }; console . log ( a . x ); //4 Duplicate property names generated a SyntaxError in ES5 when using strict mode. However, ES6 removed this limitation. Computed Property Names With ES6, you can now use computed property names. Using the square bracket notation [], we can use an expression for a property name, including concatenating strings. This can be useful in cases where we want to create certain objects based on user data (e.g. id, email, and so on). It is very useful when you need to create custom objects based on some variables. Here are three examples: Example 1 let prop = 'name' ; let id = '1234' ; let mobile = '12345678' ; let user = { [ prop ] : 'Jack' , [ `user_ ${ id } ` ] : ` ${ mobile } ` }; Example 2 var i = 0 ; var a = { [ 'foo' + ++ i ] : i , [ 'foo' + ++ i ] : i , [ 'foo' + ++ i ] : i }; Example 3 var param = 'size' ; var config = { [ param ] : 12 , [ 'mobile' + param . charAt ( 0 ). toUpperCase () + param . slice ( 1 )] : 4 }; console . log ( config . mobileSize ); Object.assign() in ES6 ES6 adds a new Object method assign() that allows us to combine multiple sources into one target to create a single new object. Object.assign() is also useful for creating a duplicate of an existing object. Let's look at the following example to see how to combine objects: let person = { name : 'Jack' , age : 18 , sex : 'male' }; let student = { name : 'Bob' , age : 20 , xp : '2' }; let student = Object . assign ({}, person , student ); Here we used Object.assign() where the first parameter is the target object you want to apply new properties to. Every parameter after the first will be used as sources for the target. There are no limitations on the number of source parameters. However, order is important because properties in the second parameter will be overridden by properties of the same name in third parameter, and so on. In the example above, we used a new object {} as the target and used two objects as sources. Now, let's see how we can use assign() to create a duplicate object without creating a reference (mutating) to the base object. In the following example, assignment was used to try to generate a new object. However, using = creates a reference to the base object. Because of this reference, changes intended for a new object mutate the original object: let person = { name : 'Jack' , age : 18 }; let newPerson = person ; //newPerson references person newPerson . name = 'Bob' ; console . log ( person . name ); //Bob console . log ( newPerson . name ); //Bob To avoid this (mutations), use Object.assign() to create a new object. For example: let person = { name : 'Jack' , age : 18 }; let newPerson = Object . assign ({}, person ); newPerson . name = 'Bob' ; console . log ( person . name ); //Jack console . log ( newPerson . name ); //Bob Finally, you can assign a value to an object property in the Object.assign() statement. For example: let person = { name : 'Jack' , age : 18 }; let newPerson = Object . assign ({}, person , { name : 'Bob' }); console . log ( person . name ); //Jack console . log ( newPerson . name ); //Bob Object Destructuring in ES6 Similar to Array destructuring, Object destructuring unpacks properties into distinct variables. For example: let obj = { h : 100 , s : true }; let { h , s } = obj ; console . log ( h ); //100 console . log ( s ); //true We can assign without declaration, but there are some syntax requirements for that: For example: let a , b ; ({ a , b } = { a : 'Hello' , b : 'world!' }); console . log ( a ); //Hello console . log ( b ); //world! The () with a semicolon (;) at the end are mandatory when destructuring without a declaration. However, you can also do it as follows where the () are not required: let { a , b } = { a : 'Hello' , b : 'world!' }; console . log ( a ); //Hello console . log ( b ); //world! You can also assign the object to new variable names. For example: var o = { h : 42 , s : true }; var { h : foo , s : bar } = o ; //console.log(h); //Error console . log ( foo ); //42 console . log ( bar ); //true Finally you can assign default values to variables, in case the value unpacked from the object is undefined. For example: var obj = { id : 42 , name : 'Carlos' }; let { id = 10 , age = 20 } = obj ; console . log ( id ); //42 console . log ( age ); //20","title":"Objects"},{"location":"js_object/#es6-objects","text":"JavaScript variables can be Object data types that contain many values called properties. An object can also have properties that are function definitions called methods for performing actions on the object. ES6 introduces shorthand notations and computed property names that make declaring and using objects easier to understand. The new method definition shorthand does not require the colon (:) or function keyword, as in the grow function of the tree object declaration: let tree = { height : 10 , color : 'green' , grow () { this . height += 2 ; } }; tree . grow (); console . log ( tree . height ); //12 You can also use a property value shorthand when initializing properties with a variable by the same name. For example, properties height and health are being initialized with variables named height and health let height = 5 ; let health = 100 ; let athlete = { height , health }; console . log ( athlete . height ); //5 console . log ( athlete . health ); //100 When creating an object by using duplicate property names, the last property will overwrite the prior ones of the same name. For Example: var a = { x : 1 , x : 2 , x : 3 , x : 4 }; console . log ( a . x ); //4 Duplicate property names generated a SyntaxError in ES5 when using strict mode. However, ES6 removed this limitation.","title":"ES6 Objects"},{"location":"js_object/#computed-property-names","text":"With ES6, you can now use computed property names. Using the square bracket notation [], we can use an expression for a property name, including concatenating strings. This can be useful in cases where we want to create certain objects based on user data (e.g. id, email, and so on). It is very useful when you need to create custom objects based on some variables. Here are three examples: Example 1 let prop = 'name' ; let id = '1234' ; let mobile = '12345678' ; let user = { [ prop ] : 'Jack' , [ `user_ ${ id } ` ] : ` ${ mobile } ` }; Example 2 var i = 0 ; var a = { [ 'foo' + ++ i ] : i , [ 'foo' + ++ i ] : i , [ 'foo' + ++ i ] : i }; Example 3 var param = 'size' ; var config = { [ param ] : 12 , [ 'mobile' + param . charAt ( 0 ). toUpperCase () + param . slice ( 1 )] : 4 }; console . log ( config . mobileSize );","title":"Computed Property Names"},{"location":"js_object/#objectassign-in-es6","text":"ES6 adds a new Object method assign() that allows us to combine multiple sources into one target to create a single new object. Object.assign() is also useful for creating a duplicate of an existing object. Let's look at the following example to see how to combine objects: let person = { name : 'Jack' , age : 18 , sex : 'male' }; let student = { name : 'Bob' , age : 20 , xp : '2' }; let student = Object . assign ({}, person , student ); Here we used Object.assign() where the first parameter is the target object you want to apply new properties to. Every parameter after the first will be used as sources for the target. There are no limitations on the number of source parameters. However, order is important because properties in the second parameter will be overridden by properties of the same name in third parameter, and so on. In the example above, we used a new object {} as the target and used two objects as sources. Now, let's see how we can use assign() to create a duplicate object without creating a reference (mutating) to the base object. In the following example, assignment was used to try to generate a new object. However, using = creates a reference to the base object. Because of this reference, changes intended for a new object mutate the original object: let person = { name : 'Jack' , age : 18 }; let newPerson = person ; //newPerson references person newPerson . name = 'Bob' ; console . log ( person . name ); //Bob console . log ( newPerson . name ); //Bob To avoid this (mutations), use Object.assign() to create a new object. For example: let person = { name : 'Jack' , age : 18 }; let newPerson = Object . assign ({}, person ); newPerson . name = 'Bob' ; console . log ( person . name ); //Jack console . log ( newPerson . name ); //Bob Finally, you can assign a value to an object property in the Object.assign() statement. For example: let person = { name : 'Jack' , age : 18 }; let newPerson = Object . assign ({}, person , { name : 'Bob' }); console . log ( person . name ); //Jack console . log ( newPerson . name ); //Bob","title":"Object.assign() in ES6"},{"location":"js_object/#object-destructuring-in-es6","text":"Similar to Array destructuring, Object destructuring unpacks properties into distinct variables. For example: let obj = { h : 100 , s : true }; let { h , s } = obj ; console . log ( h ); //100 console . log ( s ); //true We can assign without declaration, but there are some syntax requirements for that: For example: let a , b ; ({ a , b } = { a : 'Hello' , b : 'world!' }); console . log ( a ); //Hello console . log ( b ); //world! The () with a semicolon (;) at the end are mandatory when destructuring without a declaration. However, you can also do it as follows where the () are not required: let { a , b } = { a : 'Hello' , b : 'world!' }; console . log ( a ); //Hello console . log ( b ); //world! You can also assign the object to new variable names. For example: var o = { h : 42 , s : true }; var { h : foo , s : bar } = o ; //console.log(h); //Error console . log ( foo ); //42 console . log ( bar ); //true Finally you can assign default values to variables, in case the value unpacked from the object is undefined. For example: var obj = { id : 42 , name : 'Carlos' }; let { id = 10 , age = 20 } = obj ; console . log ( id ); //42 console . log ( age ); //20","title":"Object Destructuring in ES6"},{"location":"js_operators/","text":"Operators An operator is a symbol that performs mathematical or logical manipulations. Javascript supports addition (+), subtraction(-), multiplication(*), division(/) and modulus(%). Also increment (++) and decrement (--). You can get the result of a string expression using the eval() function, which takes a string expression argument like eval(\"10 * 20 + 8\") and returns the result. If the argument is empty, it returns undefined. 10 * '5' or '10' * '5' will give the same result. But trying to multiply a number with string values that aren\u2019t numbers, like 'hello' * 5 will return NaN (Not a Number). In JavaScript, we can use the modulus operator on integers AND on floating point numbers. Exponentiation operator was introduced in ES7 . console . log ( 3 ** 4 ); // expected output: 81 console . log ( 10 ** - 2 ); // expected output: 0.01 console . log ( 2 ** 3 ** 2 ); // expected output: 512 console . log (( 2 ** 3 ) ** 2 ); // expected output: 64 User must explicitly enable this feature. The Math Object The Math object allows you to perform mathematical tasks, and includes several properties. Math has no constructor. There's no need to create a Math object first. Math . E //constant e Math . PI //constant pi For exponentiation, we must use Math.pow. to calculate a number raised to the power of some other number. var number = Math . ceil ( Math . random () * 10 ); Math.abs() returns the absolute value of its parameter. Math.ceil() rounds a floating point value up to the nearest integer value. The rounded value is returned as a double Math.floor() rounds a floating point value down to the nearest integer value. Math.max() returns the largest of its parameters. Math.min() returns the smallest parameter. sqrt() for square root, sin() for sine, cos() for cosine Javascript also provides compound assignment operators that perform an operation and an assignment in one statement. In-place operators allow you to write code like 'x = x + 3;' more concisely, as 'x += 3;'. var x = 2 ; x += 3 ; x *= 4 ; x /= 2 ; The increment (and decrement) operator is used to increase (decrease) an integer's value by one. x ++ ; //equivalent to x = x + 1 x -- ; //equivalent to x = x - 1 The increment (and decrement) operator has two forms, prefix and postfix. Prefix increments the value, and then proceeds with the expression. Postfix evaluates the expression and then performs the incrementing. ++ x ; //prefix x ++ ; //postfix Logical Operators (Boolean Operators) Logical operators are used to join multiple expressions and return true or false. The AND operator (&&), the OR operator(||) and the NOT operator(!) The ?: Operator (Conditional (Ternary) Operator) Exp1 ? Exp2 : Exp3; The ?: operator works the following way: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression. var msg = ( age >= 18 ) ? \"Welcome\" : \"Sorry\" ; ES6 The Spread Operator This operator is similar to the Rest Parameter, but it has another purpose when used in objects or arrays or function calls (arguments). Spread in function calls It is common to pass the elements of an array as arguments to a function. Before ES6, we used the following method: function myFunction ( w , x , y , z ){ console . log ( w + x + y + z ); } var args = [ 1 , 2 , 3 ]; myFunction . apply ( null , args . concat ( 4 )); ES6 provides an easy way to do the example above with spread operators. const myFunction = ( w , x , y , z ) => { console . log ( w + x + y + z ); }; let args = [ 1 , 2 , 3 ]; myFunction ( ... args , 4 ); Example: var dateFields = [ 1981 , 11 , 26 ]; var date = new Date (... dateFields ); console . log ( date ); Spread in array literals Before ES6, we used the following syntax to add an item at middle of an array: var arr = [ \"One\" , \"Two\" , \"Five\" ]; arr . splice ( 2 , 0 , \"Three\" ); arr . splice ( 3 , 0 , \"Four\" ); console . log ( arr ); You can use methods such as push, splice, and concat, for example, to achieve this in different positions of the array. However, in ES6 the spread operator lets us do this more easily: let newArr = [ 'Three' , 'Four' ]; let arr = [ 'One' , 'Two' , ... NewArr , 'Five' ]; console . log ( arr ); Spread in object literals In objects it copies the own enumerable properties from the provided object onto a new object. const obj1 = { foo : 'bar' , x : 42 }; const obj2 = { foo : 'baz' , y : 5 }; const cloneObj = {... obj1 }; //{foo: 'bar', x: 42} const mergedObj = {... obj1 , ... obj2 }; //{foo: 'baz', x: 42, y: 5} However, if you try to merge them you will not get the result you expected: const obj1 = { foo : 'bar' , x : 42 }; const obj2 = { foo : 'baz' , y : 5 }; const merge = (... objects ) => ({... objects }); let mergedObj = merge ( obj1 , obj2 ); // { 0: {foo: 'bar', x: 42}, 1: {foo: 'baz', y: 5} } let mergedObj2 = merge ({}, obj1 , obj2 ); // { 0: {}, 1: {foo: 'bar', x: 42}, 2: {foo: 'baz', y: 5} } Shallow cloning or merging objects is possible with another operator called Object.assign().","title":"Operators"},{"location":"js_operators/#operators","text":"An operator is a symbol that performs mathematical or logical manipulations. Javascript supports addition (+), subtraction(-), multiplication(*), division(/) and modulus(%). Also increment (++) and decrement (--). You can get the result of a string expression using the eval() function, which takes a string expression argument like eval(\"10 * 20 + 8\") and returns the result. If the argument is empty, it returns undefined. 10 * '5' or '10' * '5' will give the same result. But trying to multiply a number with string values that aren\u2019t numbers, like 'hello' * 5 will return NaN (Not a Number). In JavaScript, we can use the modulus operator on integers AND on floating point numbers. Exponentiation operator was introduced in ES7 . console . log ( 3 ** 4 ); // expected output: 81 console . log ( 10 ** - 2 ); // expected output: 0.01 console . log ( 2 ** 3 ** 2 ); // expected output: 512 console . log (( 2 ** 3 ) ** 2 ); // expected output: 64 User must explicitly enable this feature.","title":"Operators"},{"location":"js_operators/#the-math-object","text":"The Math object allows you to perform mathematical tasks, and includes several properties. Math has no constructor. There's no need to create a Math object first. Math . E //constant e Math . PI //constant pi For exponentiation, we must use Math.pow. to calculate a number raised to the power of some other number. var number = Math . ceil ( Math . random () * 10 ); Math.abs() returns the absolute value of its parameter. Math.ceil() rounds a floating point value up to the nearest integer value. The rounded value is returned as a double Math.floor() rounds a floating point value down to the nearest integer value. Math.max() returns the largest of its parameters. Math.min() returns the smallest parameter. sqrt() for square root, sin() for sine, cos() for cosine Javascript also provides compound assignment operators that perform an operation and an assignment in one statement. In-place operators allow you to write code like 'x = x + 3;' more concisely, as 'x += 3;'. var x = 2 ; x += 3 ; x *= 4 ; x /= 2 ; The increment (and decrement) operator is used to increase (decrease) an integer's value by one. x ++ ; //equivalent to x = x + 1 x -- ; //equivalent to x = x - 1 The increment (and decrement) operator has two forms, prefix and postfix. Prefix increments the value, and then proceeds with the expression. Postfix evaluates the expression and then performs the incrementing. ++ x ; //prefix x ++ ; //postfix","title":"The Math Object"},{"location":"js_operators/#logical-operators","text":"(Boolean Operators) Logical operators are used to join multiple expressions and return true or false. The AND operator (&&), the OR operator(||) and the NOT operator(!)","title":"Logical Operators"},{"location":"js_operators/#the-operator","text":"(Conditional (Ternary) Operator) Exp1 ? Exp2 : Exp3; The ?: operator works the following way: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression. var msg = ( age >= 18 ) ? \"Welcome\" : \"Sorry\" ;","title":"The ?: Operator"},{"location":"js_operators/#es6-the-spread-operator","text":"This operator is similar to the Rest Parameter, but it has another purpose when used in objects or arrays or function calls (arguments). Spread in function calls It is common to pass the elements of an array as arguments to a function. Before ES6, we used the following method: function myFunction ( w , x , y , z ){ console . log ( w + x + y + z ); } var args = [ 1 , 2 , 3 ]; myFunction . apply ( null , args . concat ( 4 )); ES6 provides an easy way to do the example above with spread operators. const myFunction = ( w , x , y , z ) => { console . log ( w + x + y + z ); }; let args = [ 1 , 2 , 3 ]; myFunction ( ... args , 4 ); Example: var dateFields = [ 1981 , 11 , 26 ]; var date = new Date (... dateFields ); console . log ( date ); Spread in array literals Before ES6, we used the following syntax to add an item at middle of an array: var arr = [ \"One\" , \"Two\" , \"Five\" ]; arr . splice ( 2 , 0 , \"Three\" ); arr . splice ( 3 , 0 , \"Four\" ); console . log ( arr ); You can use methods such as push, splice, and concat, for example, to achieve this in different positions of the array. However, in ES6 the spread operator lets us do this more easily: let newArr = [ 'Three' , 'Four' ]; let arr = [ 'One' , 'Two' , ... NewArr , 'Five' ]; console . log ( arr ); Spread in object literals In objects it copies the own enumerable properties from the provided object onto a new object. const obj1 = { foo : 'bar' , x : 42 }; const obj2 = { foo : 'baz' , y : 5 }; const cloneObj = {... obj1 }; //{foo: 'bar', x: 42} const mergedObj = {... obj1 , ... obj2 }; //{foo: 'baz', x: 42, y: 5} However, if you try to merge them you will not get the result you expected: const obj1 = { foo : 'bar' , x : 42 }; const obj2 = { foo : 'baz' , y : 5 }; const merge = (... objects ) => ({... objects }); let mergedObj = merge ( obj1 , obj2 ); // { 0: {foo: 'bar', x: 42}, 1: {foo: 'baz', y: 5} } let mergedObj2 = merge ({}, obj1 , obj2 ); // { 0: {}, 1: {foo: 'bar', x: 42}, 2: {foo: 'baz', y: 5} } Shallow cloning or merging objects is possible with another operator called Object.assign().","title":"ES6 The Spread Operator"},{"location":"js_promises/","text":"ES6 Promises A Promise is a better way for asynchronous programming when compared to the common way of using a setTimeout() type of method. Consider this example: setTimeOut ( function () { console . log ( \"Work 1\" ); setTimeOut ( function () { console . log ( \"Work 2\" );}, 1000 ); }, 1000 ); console . log ( \"End\" ); // End // Work 1 // Work 2 It prints \"End\", \"Work 1\" and \"Work 2\" in that order (the work is done asynchronously). But if there are more events like this, the code becomes very complex. ES6 comes to the rescue in such situations. A promise can be created as follows: new Promise ( function ( resolve , reject ) { // Work if ( success ) resolve ( result ); else reject ( Error ( \"failure\" )); }); Here, resolve is the method for success and reject is the method for failure. If a method returns a promise, its calls should use the then method which takes two methods as input; one for success and the other for failure. For Example: function asyncFunc ( work ){ return new Promise ( function ( resolve , reject ) { if ( work === \"\" ) reject ( Error ( \"failure\" )); setTimeOut ( function (){ resolve ( work );}, 1000 ); }); } asyncFunc ( \"Work1\" ) //Task1 . then ( function ( result ) { console . log ( result ); return asyncFunc ( \"Work2\" ); //Task2 }, function ( error ) { console . log ( error ); }) . then ( function ( result ) { console . log ( result ); }, function ( error ) { console . log ( error ); }); console . log ( \"End\" ); // End // Work1 // Work2 It also prints \"End\", \"Work 1\" and \"Work 2\" (the work is done asynchronously). But, this is clearly more readable than the previous example and in more complex situations it is easier to work with.","title":"Promises"},{"location":"js_promises/#es6-promises","text":"A Promise is a better way for asynchronous programming when compared to the common way of using a setTimeout() type of method. Consider this example: setTimeOut ( function () { console . log ( \"Work 1\" ); setTimeOut ( function () { console . log ( \"Work 2\" );}, 1000 ); }, 1000 ); console . log ( \"End\" ); // End // Work 1 // Work 2 It prints \"End\", \"Work 1\" and \"Work 2\" in that order (the work is done asynchronously). But if there are more events like this, the code becomes very complex. ES6 comes to the rescue in such situations. A promise can be created as follows: new Promise ( function ( resolve , reject ) { // Work if ( success ) resolve ( result ); else reject ( Error ( \"failure\" )); }); Here, resolve is the method for success and reject is the method for failure. If a method returns a promise, its calls should use the then method which takes two methods as input; one for success and the other for failure. For Example: function asyncFunc ( work ){ return new Promise ( function ( resolve , reject ) { if ( work === \"\" ) reject ( Error ( \"failure\" )); setTimeOut ( function (){ resolve ( work );}, 1000 ); }); } asyncFunc ( \"Work1\" ) //Task1 . then ( function ( result ) { console . log ( result ); return asyncFunc ( \"Work2\" ); //Task2 }, function ( error ) { console . log ( error ); }) . then ( function ( result ) { console . log ( result ); }, function ( error ) { console . log ( error ); }); console . log ( \"End\" ); // End // Work1 // Work2 It also prints \"End\", \"Work 1\" and \"Work 2\" (the work is done asynchronously). But, this is clearly more readable than the previous example and in more complex situations it is easier to work with.","title":"ES6 Promises"},{"location":"js_react/","text":"Front-end development refers to what the end user (also commonly referred to as the \"client\") can see. In the most basic forms, front-end development consists of HTML, CSS, and JavaScript. As a developer, you will find that it is very easy for your front-end (website, web application, etc.) to become very complex and have a lot of different moving parts. It makes solving problems much more difficult when you have to go through a maze of code to find the issue. Eventually, developers decided that there must be a better way to manage all of that code, so they created libraries that could make life easier. React was one of those libraries. React was created by Facebook and released to the public in May of 2013 and has been consistently maintained since then. Why React? React is one of the most popular JavaScript libraries for front-end web applications. Here are some of the advantages of React: Speed : Interactive websites need to update the DOM (Document Object Model) each time a change happens. This process is generally resourceful and slow. Compared to other libraries that manipulate the DOM, React uses a Virtual DOM, allowing to update only the parts of the website that have changed. This increases the speed of updates dramatically, as modern web applications may contain thousands of elements. Ease of Use : React allows developers to group related code together, thereby making building and maintaining large scale applications much less complex. Support : React has an amazingly large community and is open source. It is maintained by Facebook and the community. Adding React React can be added to a website without any special tools and installations. First, we need to add the React library as two script tags to the head of our HTML document: < script src = \"https://unpkg.com/react@16/umd/react.development.js\" crossorigin ></ script > < script src = \"https://unpkg.com/react-dom@16/umd/react-dom.development.js\" crossorigin ></ script > Next, we need to add another script, to enable the use of JSX. JSX is a syntax extension to JavaScript, and it is recommended to be used with React. < script src = \"https://unpkg.com/babel-standalone@6/babel.min.js\" ></ script > This approach of adding React to a website is only suitable for creating small demos. After adding the required script tags, we can start building our React app! We add a container, that will be used to display something using React. < div id = \"container\" ></ div > You can use any id for your container. It will be used by React to find the container and add content to it. Now, it's time for our first React code! Let's display a simple message as a heading: < script type = \"text/babel\" > ReactDOM . render ( < h1 > Hello , React !< /h1> document . getElementById ( 'container' ) ) </ script > The code finds the container div, and adds the h1 heading to it. Create React App Real web apps have a different scale, contain multiple files, use 3rd party libraries, etc. Facebook has created a handy tool called Create React App that makes it easy to setup a React project with just a simple command! To get started, make sure you have a recent version of Node installed on your machine. Run the following commands in the Terminal to create and start a React app called \"my-app\": npx create-react-app my-app cd my-app npm start This will install all the required dependencies, configure and start the project on localhost:3000 . Create React App allows us to focus on the code, rather than installing and configuring different tools. Project Structure Let's explore the structure of our project by opening it using a code editor. The public folder contains files related to how the application will display on the client, the most important of those being index.html , which is the HTML template of our page. The src folder contains all of the JavaScript, CSS, and image files that will be compiled into a bundle file and injected into index.html . How is React compiled into a bundle file? It uses what is called a \"file loader\". In the case of Create React App, Webpack is used. Webpack creates a \"bundle\" file containing the content of multiple files that need to be \"bundled\" together and it is all added together into a single file. Instead of making the HTML file go and find multiple files, which can slow down load times tremendously, it only has to find one file. Remember, all CSS and JS files need to be added to the src folder, otherwise webpack won't see them. While there are other files in the src folder that come with Create React App when it is generated, the two files below are the only critical files: index.js : This file is the entry point into our application. In our code, a method called ReactDOM.render() is used to find an element with id=\"root\" in the HTML and add our React application inside of that element (similar to the previous lesson). App.js : This file is the main component that will be rendered to the DOM, which currently includes the React logo image and the default text, that we see in the output. Changing the Output Now, when we know how to create and run a React project, let's change the default output to a simple Hello message. To do that, we need to open src/index.js and change the code to the following: ReactDOM . render ( < h1 > Hello , React !< /h1>, document . getElementById ( 'root' ) ); A really cool feature of Create React App is Fast Refresh, which automatically reflects the changes made to the code in the browser. StackBlitz To make it easier to play around with React, we will be using StackBlitz as our online playground to enable changing and running real React code. We have removed all the extra files, such as the logo images, to make the project structure simpler. Now we have the following files: index.html: The HTML page template. index.js: The entry point of our app. style.css: the stylesheet for our project. package.json: holds various metadata relevant to the project, like dependencies. What is JSX? We will start with the <h1>Hello, React!</h1> element. As you can see, the element is not in quotes to represent a string. It's like an HTML element, however we use it right in the JavaScript code! This is called JSX, and it is a syntax extension to JavaScript. It allows us to build UI elements right in the JavaScript code! React does not require using JSX, however, it is common practice in the React community to use JSX as it eases the development of user interfaces, as well as allows React to show useful error and warning messages. Intro to JSX Let's have a look at our code again: ReactDOM . render ( < h1 > Hello , React !< /h1>, document . getElementById ( 'root' ) ); The code calls React's render method, and passes it two arguments, a JSX element and a container. The render method displays the provided element in the container, which, in our case, is the HTML element with id=\"root\". When you call the render method, any existing content of the container gets replaced. That is why, usually, the containers are empty in the HTML. Expressions in JSX We can use any JavaScript expression inside JSX using curly braces. For example: const name = \"David\" ; const el = < p > Hello , { name } < /p>; ReactDOM . render ( el , document . getElementById ( 'root' ) ); In the example above, we use the variable name in the JSX element. As you can see, JSX can be used just like JavaScript expressions. You can assign a JSX expression to a variable, return it from a function, etc. Attributes in JSX We can specify attributes using quotes, just like in HTML: < div id = \"name\" ></ div > When using a JavaScript expression as the attributes value, the quotes should not be used: < div id = {user.id} ></ div > React DOM uses camelCase property naming convention instead of HTML attribute names. For example, class becomes className in JSX. How Does JSX Work? When the JSX expressions are compiled, they are converted into JavaScript objects, representing React elements. React then uses these elements to build the corresponding HTML DOM and display it in the browser. Let's create a counter app, that increments a counter variable every second and displays it on the page as a paragraph: let counter = 0 ; function show () { counter ++ ; const el = < p > { counter } < /p>; ReactDOM . render ( el , document . getElementById ( 'root' ) ); } setInterval ( show , 1000 ); Try it on StackBlitz We use setInterval to call the show function every second and render the counter element on the page. One of the great features of React is that it updates only the elements that need an update. You can inspect the HTML output of the example above and see that only the text in the paragraph gets updated every second. In practice, most React apps call ReactDOM.render() once. Virtual DOM We learned in the previous part that React updates only the elements that are necessary. This allows React apps to be much faster than apps built with other front-end technologies. But how does React achieve that? React uses a Virtual DOM, which is a lightweight representation of the DOM. When an element gets changed, it is first updated in the Virtual DOM. That process is fast, as the virtual DOM is represented by simple objects. After that, React compares the Virtual DOM to its previous state and only applies the DOM updates necessary to bring the DOM to the desired state. DOM stands for Document Object Model and is a tree-like representation of the HTML page. Components Components let you split the page into independent and reusable parts. Notice that the page can be split into multiple parts. Each of these \"parts\" are a component. The heading is a component, the button is a component, and the search bar is its own component. This makes organizing the page leaps and bounds easier, but even more importantly, components allow us as the developers to separate concerns from one another. Separation of concerns is a programming principle that states that each concern should be separated into individual pieces. Functional Components In React, there are two types of components that you can use: Functional Components and Class Components. In this part, we will talk about functional components. A functional component is a simple JavaScript function: function Hello () { return < h1 > Hello world . < /h1>; } The code above defined a functional component called Hello, that returns a simple React element. Notice that the name of the functional component begins with a capital letter. This is absolutely critical. If we start the name of a component with a lowercase letter, the browser will treat our component like a regular HTML element instead of a Component. Rendering Components In order to display the component, we need to create the corresponding JSX element. For example, for our user-defined component Hello: const el = < Hello /> ; Now, we can use our user-defined element and render it on the page: function Hello () { return < h1 > Hello world . < /h1>; } const el = < Hello /> ; ReactDOM . render ( el , document . getElementById ( 'root' ) ); Remember, all component names need to start with a capital letter. Class Components Class components are typically used when there are more advanced user interactions, like forms, and animations. All class components need to extend the React.Component class. We can rewrite our Hello functional component as a class component: class Hello extends React . Component { render () { return < h1 > Hello world . < /h1>; } } Class components need to have a render method, which is in charge of telling what the page should show. Props Functional components can accept arguments, similar to JavaScript functions. These arguments are called props, and represent an object. For example, we can use props in our Hello component: function Hello ( props ) { return < p > Hello , { props . name } !< /p>; } Now, we can add a name attribute to our element: const el = < Hello name = \"David\" /> ; The attribute value will be passed to the component when rendered. An element can have multiple custom attributes, which will be passed to the component using the props object. You can use any custom names for your attributes. Components using Components Components can use other components to generate an output. For example: function App () { return < div > < Hello name = \"David\" /> < Hello name = \"James\" /> < Hello name = \"Amy\" /> < /div>; } Here, our App component uses the Hello component three times, each times with a new name attribute. Generally, it is a good practice to split complex components into multiple smaller components, that are reusable. For example, a Post component can use an Avatar component, an Image component, a Date component, etc. Props in Class Components Props can be accessed in class components using this.props. For example: class Hello extends React . Component { render () { return < p > Hello , { this . props . name } !< /p>; } } An important thing to consider is that props are read-only, meaning components cannot modify their props. Interactive apps generally need to change data and the page elements. An Example Now that we know how to create components and pass them data, let's create a shopping list. Each item in our list will have a name and a price. For example: < Item name = \"Cheese\" price = \"4.99\" /> The Item component will render a simple div element with the data: function Item ( props ) { return < div className = \"item\" > < b > Name :< /b> {props.name} <br / > < b > Price :< /b> {props.price} < /div>; } Now we can use our component and create multiple items for our shopping list: < Item name = \"Cheese\" price = \"4.99\" /> < Item name = \"Bread\" price = \"1.5\" /> < Item name = \"Ice cream\" price = \"24\" /> We have added some simple CSS styles to separate the items visually. State Up until this point, we have learned how to pass data to components using props. Many web apps need their components to change their data, for example, after user interaction (clicking a button, submitting a form, etc.). However, props cannot be changed. In order to allow components to manage and change their data, React provides a feature called state. State is an object that is added as a property in class components. For example: class Hello extends React . Component { state = { name : \"James\" } render () { return < h1 > Hello { this . state . name }. < /h1>; } } As you can see, state is just a simple object, that contains key:value pairs. Similar to props, the values can be accessed using this.state. Now, when the component renders, the state is initialized with the given value and there will be a heading that says \"Hello James.\" . The state object can contain multiple key:value pairs, separated by commas. Changing State State should not be modified directly. Instead, React provides a setState() method, that can be used to modify state. For example: this . setState ({ name : \"James\" , age : 25 }); You need to pass an object with the new key:value pairs to the setState method. Why should we use setState, instead of simply changing the values of the object properties directly? The answer uncovers one of the most useful features of React: when setState is called, React automatically re-renders the affected component with the new state! Usually, the change in state happens in event handlers. We will look at an example in the next part! When state changes using the setState method, React gets informed and immediately re-renders the component with the updated state. Counter App To better understand how state works, let's create a counter app, which increments the counter each time a button is clicked. We start by creating our Counter component, which includes the counter and a button: class Counter extends React . Component { state = { counter : 0 } render () { return < div > < p > { this . state . counter } < /p> < button > Increment < /button> < /div>; } } We have initialized our counter to the value 0 in the state. Now, we need to add a click event handler to the button and increment the counter in the state. Here is the final code: class Counter extends React . Component { state = { counter : 0 } increment = () => { this . setState ({ counter : this . state . counter + 1 }); } render () { return < div > < p > { this . state . counter } < /p> < button onClick = { this . increment } > Increment < /button> < /div>; } } The onClick event calls the increment function of our component, which uses setState to change the value of our counter. When the state is changed, React automatically triggers a re-render of the component. Notice that the event handler uses camelCase syntax and that the handler function is passed in curly braces. Props vs State As a recap, here is a summary of the main differences between props and state: We use props to pass data to components. Components use state to manage their data. Props are read-only and cannot be modified. State can be modified by its component using the setState() method. The setState() method results in re-rendering the component affected. Components that have state are called stateful, while components that do not use state are called stateless. Hooks Earlier version of React allowed to use state only with class components. In recent iterations of React, a new feature called hooks was introduced, allowing to use state inside of functional components. First, we need to import the useState hook: import React , { useState } from 'react' ; useState returns a pair, the current state value and a function, that lets you change the state. useState takes one argument, which is the initial value of the state. Let's look at an example: function Hello () { const [ name , setName ] = useState ( \"David\" ); return < h1 > Hello { name }. < /h1>; } In the example above, we create a name state variable and a setName function. The square brackets syntax is called array destructuring. It assigns the name variable to the current state value, and setName to the function that allows to change the state. You can name these variables anything you like. Then, we pass \"David\" as the initial value for our name variable to useState(). You can create multiple state variables with their corresponding set methods. Just use separate statements for each variable using the useState hook. Counter App using Hooks Now we can rewrite our Counter app from the previous lesson using a functional component and hooks! Here is the code: function Counter () { const [ counter , setCounter ] = useState ( 0 ); function increment () { setCounter ( counter + 1 ); } return < div > < p > { counter } < /p> < button onClick = { increment } > Increment < /button> < /div>; } As you can see, compared to the class component, the code is much shorter and easier to read and understand. That was one of the reasons why the React team created Hooks. Remember, hooks can only be used inside functional components. Hooks are functions that allow to \"hook into\" React features from function components. Lifecycle Methods React provides special lifecycle methods for class components, which are called when components are mounted, updated or unmounted. Mounting is the process when a component is rendered on the page. Unmounting is the process when a component is removed from the page. The componentDidMount method is called when a component is rendered on the page. For example, we can use componentDidMount in our Counter app to set the initial value of the counter: componentDidMount () { this . setState ({ counter : 42 }); } This will set an initial value of the counter when the component is rendered. componentDidMount is typically used for populating the state inside of a component when it initially mounts to the DOM. Similarly, the componentWillUnmount() lifecycle method is called right before the component is removed from the DOM. It can be used to free up resources taken by the component. componentDidUpdate Another lifecycle method is componentDidUpdate(), which is called when a component is updated in the DOM. We can, for example, alert the current counter value when it is incremented: componentDidUpdate () { alert ( \"Number of clicks: \" + this . state . counter ); } componentDidUpdate() is only called when the component is updated. The useEffect Hook The lifecycle methods we covered are only available for class components. However, React provides a special Hook called useEffect to make lifecycle methods available in functional components. It combines the componentDidMount, componentDidUpdate, and componentWillUnmount methods into one. For example, we can achieve the behavior of our last example using a functional Counter component: function Counter () { const [ counter , setCounter ] = useState ( 0 ); useEffect (() => { alert ( \"Number of clicks: \" + counter ); }); function increment () { setCounter ( counter + 1 ); } return < div > < p > { counter } < /p> < button onClick = { increment } > Increment < /button> < /div>; } When you run the code, you'll notice that the alert dialog appears also during the first render. This is caused by the fact that, by default, useEffect runs both, after the first render and after every update. To call the method only when something changes, we can provide it a second argument: useEffect (() => { //do something }, [ count ]); Now, the useEffect() method will run only if count changes. To mimic componentWillUnmount, useEffect may return a function that cleans up after it: useEffect (() => { // do something return () => { // cleanup }; }); You can have multiple effects in the same component. Just like with the useState hook, we need to import useEffect to be able to use it: import React , { useState , useEffect } from 'react' ; Event Handling Handling events in React is very similar to handling events in the DOM. The only difference is that event names use camelCase syntax and the event handler needs to be passed in curly braces. For example, to handle the click event on a button: < button onClick = { handleClick } > My Button < /button> Clicking the button will call the handleClick function of the component. Let's explore our Counter app: function Counter () { const [ counter , setCounter ] = useState ( 0 ); function increment () { setCounter ( counter + 1 ); } return < div > < p > { counter } < /p> < button onClick = { increment } > Increment < /button> < /div>; } The onClick event calls the increment function, which is incrementing the counter state variable. Check out the same Counter app built using a class component here. Handling User Input One of the common ways that users interact with web pages is through text fields. We can handle user input in React using the onChange event of the text field. When the value of the text field changes, the event handler is called, updating the value of the field in the component's state. This way you always have the actual value of the text field in the state. Let's make an app to convert Km to Miles. We will take the Km value from a text field and calculate the miles value upon input: function Converter () { const [ km , setKm ] = useState ( 0 ); function handleChange ( e ) { setKm ( e . target . value ); } function convert ( km ) { return ( km / 1.609 ). toFixed ( 2 ); } return < div > < input type = \"text\" value = { km } onChange = { handleChange } /> < p > { km } km is { convert ( km )} miles < /p> < /div>; } Our Converter component includes a text field, which calls the handleChange function when its value changes. The handleChange function updates the state with the current value of the textfield, causing the component to re-render and show the corresponding miles value, which is calculated using the convert function. The value of the text field is accessed via the e object, which represents the React event. It is passed to the event handler function as an argument and can be used to access the event object. Forms In the previous part, we learned how to handle user input in text fields. Text fields are usually part of a form. Similar to the previous example, React form elements keep their state and update it based on user input. This way you always have the data of your form at your disposal in the state. To demonstrate this, we will create a form, that will add numbers every time the form is submitted and display the sum. Our form contains an input field and a submit button: function AddForm () { const [ sum , setSum ] = useState ( 0 ); const [ num , setNum ] = useState ( 0 ); function handleChange ( e ) { setNum ( e . target . value ); } function handleSubmit ( e ) { setSum ( sum + Number ( num )); e . preventDefault (); } return < form onSubmit = { handleSubmit } > < input type = \"number\" value = { num } onChange = { handleChange } /> < input type = \"submit\" value = \"Add\" /> < p > Sum is { sum } < /p> < /form>; } In the code above, the value of the input is controlled by React (we keep the value in the state). When the form is submitted using the submit button, the handleSubmit function gets called, which updates the value of sum in the state. An input form element whose value is controlled by React in this way is called a \"controlled component\". Notice the e.preventDefault(); statement. This statement prevents the default behavior of the form, which, by default, reloads the page when submitted. In JavaScript we would use return false; for that, but in React we need to call preventDefault(). Lists Web apps commonly contain repeating elements, such as lists or sections, where the same DOM element is repeated with a different data set. Consider an array of strings: const arr = [ \"A\" , \"B\" , \"C\" ]; We need to render a list element for each item in the array. We can define a MyList component and pass it the array as a prop using a custom data attribute: < MyList data = { arr } /> Now, when the array is accessible via props, we can write the component logic: function MyList ( props ) { const arr = props . data ; const listItems = arr . map (( val ) => < li > { val } < /li> ); return < ul > { listItems } < /ul>; } We take the input array from the incoming props, loop through the array using the JavaScript map function and return a <li> element for each item. The resulted array is stored in the listItems variable. Then, the component returns the listItems array inside a <ul> tag. This code results in a warning, saying that each element needs a unique key Keys Each element in a list must have a key attribute. Keys act as a unique identity, identifying each element. Usually, these are IDs from your data, or can be auto-generated indexes. For example: const listItems = arr . map (( val , index ) => < li key = { index } > { val } < /li> ); Keys are important, because they uniquely identify elements, helping React understand which items have changed, are added, or are removed. Example : Contact Manager Let's build a contact manager app. We will use a form to add new contacts to the list and display them in a list. AddPersonForm Our AddPersonForm component uses state to manage the value of the text field: function AddPersonForm () { const [ person , setPerson ] = useState ( \"\" ); function handleChange ( e ) { setPerson ( e . target . value ); } function handleSubmit ( e ) { e . preventDefault (); } return ( < form onSubmit = { handleSubmit } > < input type = \"text\" placeholder = \"Add new contact\" onChange = { handleChange } value = { person } /> < button type = \"submit\" > Add < /button> < /form> ); } For now, we just prevent the default behavior when the form is submitted. PeopleList received an array representing the contacts and renders a list on the page: function PeopleList ( props ) { const arr = props . data ; const listItems = arr . map (( val , index ) => < li key = { index } > { val } < /li> ); return < ul > { listItems } < /ul>; } Now we can render our components on the page and include some initial data: const contacts = [ \"James Smith\" , \"Thomas Anderson\" , \"Bruce Wayne\" ]; const el = ( < div > < AddPersonForm /> < PeopleList data = { contacts } /> < /div> ); ReactDOM . render ( el , document . getElementById ( \"root\" )); Adding a new contact does not work, as we have not built the logic in the handleSubmit function yet. Sharing State Right now, our AddPersonForm independently keeps its state. How can we add a new contact to our PeopleList then, when the form is submitted? To accomplish that, we need to share the state between the components. We can do that by lifting the state up to a parent component. This means that the parent component will hold the data that needs to be shared between the components. In our case, that is the contacts list. Let's create a parent component called ContactManager, which includes the AddPersonForm and PeopleList as child components and holds the contacts list in its state: function ContactManager ( props ) { const [ contacts , setContacts ] = useState ( props . data ); return ( < div > < AddPersonForm /> < PeopleList data = { contacts } /> < /div> ); } The ContactManager component receives the initial contacts list using props, saves it in its state. Then it passes down the contacts list to its child component. Data can be passed from the parent to the child, but not from the child to the parent. React uses what is called unidirectional data flow, in other words, data only flows downward, so to speak. Adding a Contact Now, we can create an addPerson() function to our ContactManager component to add a new person to our contacts state array: function ContactManager ( props ) { const [ contacts , setContacts ] = useState ( props . data ); function addPerson ( name ) { setContacts ([... contacts , name ]); } ... } But how are we going to call this function from our child AddPersonForm component, where the data for the new person is stored? Just like we passed down data using props, React allows us to pass down function references! function ContactManager ( props ) { const [ contacts , setContacts ] = useState ( props . data ); function addPerson ( name ) { setContacts ([... contacts , name ]); } return ( < div > < AddPersonForm handleSubmit = { addPerson } /> < PeopleList data = { contacts } /> < /div> ); } Similar to passing the contacts list to our PeopleList component, we passed down the addPerson() function to our AddPersonForm using a prop called handleSubmit. Now, our PeopleList can call the handleSubmit function that it received when the form is submitted, to add a new person to the list: function AddPersonForm ( props ) { const [ person , setPerson ] = useState ( '' ); function handleChange ( e ) { setPerson ( e . target . value ); } function handleSubmit ( e ) { props . handleSubmit ( person ); setPerson ( '' ); e . preventDefault (); } return ( < form onSubmit = { handleSubmit } > < input type = \"text\" placeholder = \"Add new contact\" onChange = { handleChange } value = { person } /> < button type = \"submit\" > Add < /button> < /form> ); } We also clear the value of the text field using setPerson('') after adding a new person. Summary An important takeaway from this lesson is that props can be used to pass down not only state, but also functions, that may manipulate the state. This way, we are able to store the application state in the parent and allow its child components to use and manipulate the state. Now, when our app is fully functional, we can add some CSS styles and a check, to prevent creation of blank contacts.","title":"React"},{"location":"js_react/#why-react","text":"React is one of the most popular JavaScript libraries for front-end web applications. Here are some of the advantages of React: Speed : Interactive websites need to update the DOM (Document Object Model) each time a change happens. This process is generally resourceful and slow. Compared to other libraries that manipulate the DOM, React uses a Virtual DOM, allowing to update only the parts of the website that have changed. This increases the speed of updates dramatically, as modern web applications may contain thousands of elements. Ease of Use : React allows developers to group related code together, thereby making building and maintaining large scale applications much less complex. Support : React has an amazingly large community and is open source. It is maintained by Facebook and the community.","title":"Why React?"},{"location":"js_react/#adding-react","text":"React can be added to a website without any special tools and installations. First, we need to add the React library as two script tags to the head of our HTML document: < script src = \"https://unpkg.com/react@16/umd/react.development.js\" crossorigin ></ script > < script src = \"https://unpkg.com/react-dom@16/umd/react-dom.development.js\" crossorigin ></ script > Next, we need to add another script, to enable the use of JSX. JSX is a syntax extension to JavaScript, and it is recommended to be used with React. < script src = \"https://unpkg.com/babel-standalone@6/babel.min.js\" ></ script > This approach of adding React to a website is only suitable for creating small demos. After adding the required script tags, we can start building our React app! We add a container, that will be used to display something using React. < div id = \"container\" ></ div > You can use any id for your container. It will be used by React to find the container and add content to it. Now, it's time for our first React code! Let's display a simple message as a heading: < script type = \"text/babel\" > ReactDOM . render ( < h1 > Hello , React !< /h1> document . getElementById ( 'container' ) ) </ script > The code finds the container div, and adds the h1 heading to it.","title":"Adding React"},{"location":"js_react/#create-react-app","text":"Real web apps have a different scale, contain multiple files, use 3rd party libraries, etc. Facebook has created a handy tool called Create React App that makes it easy to setup a React project with just a simple command! To get started, make sure you have a recent version of Node installed on your machine. Run the following commands in the Terminal to create and start a React app called \"my-app\": npx create-react-app my-app cd my-app npm start This will install all the required dependencies, configure and start the project on localhost:3000 . Create React App allows us to focus on the code, rather than installing and configuring different tools.","title":"Create React App"},{"location":"js_react/#project-structure","text":"Let's explore the structure of our project by opening it using a code editor. The public folder contains files related to how the application will display on the client, the most important of those being index.html , which is the HTML template of our page. The src folder contains all of the JavaScript, CSS, and image files that will be compiled into a bundle file and injected into index.html . How is React compiled into a bundle file? It uses what is called a \"file loader\". In the case of Create React App, Webpack is used. Webpack creates a \"bundle\" file containing the content of multiple files that need to be \"bundled\" together and it is all added together into a single file. Instead of making the HTML file go and find multiple files, which can slow down load times tremendously, it only has to find one file. Remember, all CSS and JS files need to be added to the src folder, otherwise webpack won't see them. While there are other files in the src folder that come with Create React App when it is generated, the two files below are the only critical files: index.js : This file is the entry point into our application. In our code, a method called ReactDOM.render() is used to find an element with id=\"root\" in the HTML and add our React application inside of that element (similar to the previous lesson). App.js : This file is the main component that will be rendered to the DOM, which currently includes the React logo image and the default text, that we see in the output.","title":"Project Structure"},{"location":"js_react/#changing-the-output","text":"Now, when we know how to create and run a React project, let's change the default output to a simple Hello message. To do that, we need to open src/index.js and change the code to the following: ReactDOM . render ( < h1 > Hello , React !< /h1>, document . getElementById ( 'root' ) ); A really cool feature of Create React App is Fast Refresh, which automatically reflects the changes made to the code in the browser.","title":"Changing the Output"},{"location":"js_react/#stackblitz","text":"To make it easier to play around with React, we will be using StackBlitz as our online playground to enable changing and running real React code. We have removed all the extra files, such as the logo images, to make the project structure simpler. Now we have the following files: index.html: The HTML page template. index.js: The entry point of our app. style.css: the stylesheet for our project. package.json: holds various metadata relevant to the project, like dependencies.","title":"StackBlitz"},{"location":"js_react/#what-is-jsx","text":"We will start with the <h1>Hello, React!</h1> element. As you can see, the element is not in quotes to represent a string. It's like an HTML element, however we use it right in the JavaScript code! This is called JSX, and it is a syntax extension to JavaScript. It allows us to build UI elements right in the JavaScript code! React does not require using JSX, however, it is common practice in the React community to use JSX as it eases the development of user interfaces, as well as allows React to show useful error and warning messages.","title":"What is JSX?"},{"location":"js_react/#intro-to-jsx","text":"Let's have a look at our code again: ReactDOM . render ( < h1 > Hello , React !< /h1>, document . getElementById ( 'root' ) ); The code calls React's render method, and passes it two arguments, a JSX element and a container. The render method displays the provided element in the container, which, in our case, is the HTML element with id=\"root\". When you call the render method, any existing content of the container gets replaced. That is why, usually, the containers are empty in the HTML.","title":"Intro to JSX"},{"location":"js_react/#expressions-in-jsx","text":"We can use any JavaScript expression inside JSX using curly braces. For example: const name = \"David\" ; const el = < p > Hello , { name } < /p>; ReactDOM . render ( el , document . getElementById ( 'root' ) ); In the example above, we use the variable name in the JSX element. As you can see, JSX can be used just like JavaScript expressions. You can assign a JSX expression to a variable, return it from a function, etc.","title":"Expressions in JSX"},{"location":"js_react/#attributes-in-jsx","text":"We can specify attributes using quotes, just like in HTML: < div id = \"name\" ></ div > When using a JavaScript expression as the attributes value, the quotes should not be used: < div id = {user.id} ></ div > React DOM uses camelCase property naming convention instead of HTML attribute names. For example, class becomes className in JSX.","title":"Attributes in JSX"},{"location":"js_react/#how-does-jsx-work","text":"When the JSX expressions are compiled, they are converted into JavaScript objects, representing React elements. React then uses these elements to build the corresponding HTML DOM and display it in the browser. Let's create a counter app, that increments a counter variable every second and displays it on the page as a paragraph: let counter = 0 ; function show () { counter ++ ; const el = < p > { counter } < /p>; ReactDOM . render ( el , document . getElementById ( 'root' ) ); } setInterval ( show , 1000 ); Try it on StackBlitz We use setInterval to call the show function every second and render the counter element on the page. One of the great features of React is that it updates only the elements that need an update. You can inspect the HTML output of the example above and see that only the text in the paragraph gets updated every second. In practice, most React apps call ReactDOM.render() once.","title":"How Does JSX Work?"},{"location":"js_react/#virtual-dom","text":"We learned in the previous part that React updates only the elements that are necessary. This allows React apps to be much faster than apps built with other front-end technologies. But how does React achieve that? React uses a Virtual DOM, which is a lightweight representation of the DOM. When an element gets changed, it is first updated in the Virtual DOM. That process is fast, as the virtual DOM is represented by simple objects. After that, React compares the Virtual DOM to its previous state and only applies the DOM updates necessary to bring the DOM to the desired state. DOM stands for Document Object Model and is a tree-like representation of the HTML page.","title":"Virtual DOM"},{"location":"js_react/#components","text":"Components let you split the page into independent and reusable parts. Notice that the page can be split into multiple parts. Each of these \"parts\" are a component. The heading is a component, the button is a component, and the search bar is its own component. This makes organizing the page leaps and bounds easier, but even more importantly, components allow us as the developers to separate concerns from one another. Separation of concerns is a programming principle that states that each concern should be separated into individual pieces.","title":"Components"},{"location":"js_react/#functional-components","text":"In React, there are two types of components that you can use: Functional Components and Class Components. In this part, we will talk about functional components. A functional component is a simple JavaScript function: function Hello () { return < h1 > Hello world . < /h1>; } The code above defined a functional component called Hello, that returns a simple React element. Notice that the name of the functional component begins with a capital letter. This is absolutely critical. If we start the name of a component with a lowercase letter, the browser will treat our component like a regular HTML element instead of a Component.","title":"Functional Components"},{"location":"js_react/#rendering-components","text":"In order to display the component, we need to create the corresponding JSX element. For example, for our user-defined component Hello: const el = < Hello /> ; Now, we can use our user-defined element and render it on the page: function Hello () { return < h1 > Hello world . < /h1>; } const el = < Hello /> ; ReactDOM . render ( el , document . getElementById ( 'root' ) ); Remember, all component names need to start with a capital letter.","title":"Rendering Components"},{"location":"js_react/#class-components","text":"Class components are typically used when there are more advanced user interactions, like forms, and animations. All class components need to extend the React.Component class. We can rewrite our Hello functional component as a class component: class Hello extends React . Component { render () { return < h1 > Hello world . < /h1>; } } Class components need to have a render method, which is in charge of telling what the page should show.","title":"Class Components"},{"location":"js_react/#props","text":"Functional components can accept arguments, similar to JavaScript functions. These arguments are called props, and represent an object. For example, we can use props in our Hello component: function Hello ( props ) { return < p > Hello , { props . name } !< /p>; } Now, we can add a name attribute to our element: const el = < Hello name = \"David\" /> ; The attribute value will be passed to the component when rendered. An element can have multiple custom attributes, which will be passed to the component using the props object. You can use any custom names for your attributes.","title":"Props"},{"location":"js_react/#components-using-components","text":"Components can use other components to generate an output. For example: function App () { return < div > < Hello name = \"David\" /> < Hello name = \"James\" /> < Hello name = \"Amy\" /> < /div>; } Here, our App component uses the Hello component three times, each times with a new name attribute. Generally, it is a good practice to split complex components into multiple smaller components, that are reusable. For example, a Post component can use an Avatar component, an Image component, a Date component, etc.","title":"Components using Components"},{"location":"js_react/#props-in-class-components","text":"Props can be accessed in class components using this.props. For example: class Hello extends React . Component { render () { return < p > Hello , { this . props . name } !< /p>; } } An important thing to consider is that props are read-only, meaning components cannot modify their props. Interactive apps generally need to change data and the page elements.","title":"Props in Class Components"},{"location":"js_react/#an-example","text":"Now that we know how to create components and pass them data, let's create a shopping list. Each item in our list will have a name and a price. For example: < Item name = \"Cheese\" price = \"4.99\" /> The Item component will render a simple div element with the data: function Item ( props ) { return < div className = \"item\" > < b > Name :< /b> {props.name} <br / > < b > Price :< /b> {props.price} < /div>; } Now we can use our component and create multiple items for our shopping list: < Item name = \"Cheese\" price = \"4.99\" /> < Item name = \"Bread\" price = \"1.5\" /> < Item name = \"Ice cream\" price = \"24\" /> We have added some simple CSS styles to separate the items visually.","title":"An Example"},{"location":"js_react/#state","text":"Up until this point, we have learned how to pass data to components using props. Many web apps need their components to change their data, for example, after user interaction (clicking a button, submitting a form, etc.). However, props cannot be changed. In order to allow components to manage and change their data, React provides a feature called state. State is an object that is added as a property in class components. For example: class Hello extends React . Component { state = { name : \"James\" } render () { return < h1 > Hello { this . state . name }. < /h1>; } } As you can see, state is just a simple object, that contains key:value pairs. Similar to props, the values can be accessed using this.state. Now, when the component renders, the state is initialized with the given value and there will be a heading that says \"Hello James.\" . The state object can contain multiple key:value pairs, separated by commas.","title":"State"},{"location":"js_react/#changing-state","text":"State should not be modified directly. Instead, React provides a setState() method, that can be used to modify state. For example: this . setState ({ name : \"James\" , age : 25 }); You need to pass an object with the new key:value pairs to the setState method. Why should we use setState, instead of simply changing the values of the object properties directly? The answer uncovers one of the most useful features of React: when setState is called, React automatically re-renders the affected component with the new state! Usually, the change in state happens in event handlers. We will look at an example in the next part! When state changes using the setState method, React gets informed and immediately re-renders the component with the updated state.","title":"Changing State"},{"location":"js_react/#counter-app","text":"To better understand how state works, let's create a counter app, which increments the counter each time a button is clicked. We start by creating our Counter component, which includes the counter and a button: class Counter extends React . Component { state = { counter : 0 } render () { return < div > < p > { this . state . counter } < /p> < button > Increment < /button> < /div>; } } We have initialized our counter to the value 0 in the state. Now, we need to add a click event handler to the button and increment the counter in the state. Here is the final code: class Counter extends React . Component { state = { counter : 0 } increment = () => { this . setState ({ counter : this . state . counter + 1 }); } render () { return < div > < p > { this . state . counter } < /p> < button onClick = { this . increment } > Increment < /button> < /div>; } } The onClick event calls the increment function of our component, which uses setState to change the value of our counter. When the state is changed, React automatically triggers a re-render of the component. Notice that the event handler uses camelCase syntax and that the handler function is passed in curly braces.","title":"Counter App"},{"location":"js_react/#props-vs-state","text":"As a recap, here is a summary of the main differences between props and state: We use props to pass data to components. Components use state to manage their data. Props are read-only and cannot be modified. State can be modified by its component using the setState() method. The setState() method results in re-rendering the component affected. Components that have state are called stateful, while components that do not use state are called stateless.","title":"Props vs State"},{"location":"js_react/#hooks","text":"Earlier version of React allowed to use state only with class components. In recent iterations of React, a new feature called hooks was introduced, allowing to use state inside of functional components. First, we need to import the useState hook: import React , { useState } from 'react' ; useState returns a pair, the current state value and a function, that lets you change the state. useState takes one argument, which is the initial value of the state. Let's look at an example: function Hello () { const [ name , setName ] = useState ( \"David\" ); return < h1 > Hello { name }. < /h1>; } In the example above, we create a name state variable and a setName function. The square brackets syntax is called array destructuring. It assigns the name variable to the current state value, and setName to the function that allows to change the state. You can name these variables anything you like. Then, we pass \"David\" as the initial value for our name variable to useState(). You can create multiple state variables with their corresponding set methods. Just use separate statements for each variable using the useState hook.","title":"Hooks"},{"location":"js_react/#counter-app-using-hooks","text":"Now we can rewrite our Counter app from the previous lesson using a functional component and hooks! Here is the code: function Counter () { const [ counter , setCounter ] = useState ( 0 ); function increment () { setCounter ( counter + 1 ); } return < div > < p > { counter } < /p> < button onClick = { increment } > Increment < /button> < /div>; } As you can see, compared to the class component, the code is much shorter and easier to read and understand. That was one of the reasons why the React team created Hooks. Remember, hooks can only be used inside functional components. Hooks are functions that allow to \"hook into\" React features from function components.","title":"Counter App using Hooks"},{"location":"js_react/#lifecycle-methods","text":"React provides special lifecycle methods for class components, which are called when components are mounted, updated or unmounted. Mounting is the process when a component is rendered on the page. Unmounting is the process when a component is removed from the page. The componentDidMount method is called when a component is rendered on the page. For example, we can use componentDidMount in our Counter app to set the initial value of the counter: componentDidMount () { this . setState ({ counter : 42 }); } This will set an initial value of the counter when the component is rendered. componentDidMount is typically used for populating the state inside of a component when it initially mounts to the DOM. Similarly, the componentWillUnmount() lifecycle method is called right before the component is removed from the DOM. It can be used to free up resources taken by the component.","title":"Lifecycle Methods"},{"location":"js_react/#componentdidupdate","text":"Another lifecycle method is componentDidUpdate(), which is called when a component is updated in the DOM. We can, for example, alert the current counter value when it is incremented: componentDidUpdate () { alert ( \"Number of clicks: \" + this . state . counter ); } componentDidUpdate() is only called when the component is updated.","title":"componentDidUpdate"},{"location":"js_react/#the-useeffect-hook","text":"The lifecycle methods we covered are only available for class components. However, React provides a special Hook called useEffect to make lifecycle methods available in functional components. It combines the componentDidMount, componentDidUpdate, and componentWillUnmount methods into one. For example, we can achieve the behavior of our last example using a functional Counter component: function Counter () { const [ counter , setCounter ] = useState ( 0 ); useEffect (() => { alert ( \"Number of clicks: \" + counter ); }); function increment () { setCounter ( counter + 1 ); } return < div > < p > { counter } < /p> < button onClick = { increment } > Increment < /button> < /div>; } When you run the code, you'll notice that the alert dialog appears also during the first render. This is caused by the fact that, by default, useEffect runs both, after the first render and after every update. To call the method only when something changes, we can provide it a second argument: useEffect (() => { //do something }, [ count ]); Now, the useEffect() method will run only if count changes. To mimic componentWillUnmount, useEffect may return a function that cleans up after it: useEffect (() => { // do something return () => { // cleanup }; }); You can have multiple effects in the same component. Just like with the useState hook, we need to import useEffect to be able to use it: import React , { useState , useEffect } from 'react' ;","title":"The useEffect Hook"},{"location":"js_react/#event-handling","text":"Handling events in React is very similar to handling events in the DOM. The only difference is that event names use camelCase syntax and the event handler needs to be passed in curly braces. For example, to handle the click event on a button: < button onClick = { handleClick } > My Button < /button> Clicking the button will call the handleClick function of the component. Let's explore our Counter app: function Counter () { const [ counter , setCounter ] = useState ( 0 ); function increment () { setCounter ( counter + 1 ); } return < div > < p > { counter } < /p> < button onClick = { increment } > Increment < /button> < /div>; } The onClick event calls the increment function, which is incrementing the counter state variable. Check out the same Counter app built using a class component here.","title":"Event Handling"},{"location":"js_react/#handling-user-input","text":"One of the common ways that users interact with web pages is through text fields. We can handle user input in React using the onChange event of the text field. When the value of the text field changes, the event handler is called, updating the value of the field in the component's state. This way you always have the actual value of the text field in the state. Let's make an app to convert Km to Miles. We will take the Km value from a text field and calculate the miles value upon input: function Converter () { const [ km , setKm ] = useState ( 0 ); function handleChange ( e ) { setKm ( e . target . value ); } function convert ( km ) { return ( km / 1.609 ). toFixed ( 2 ); } return < div > < input type = \"text\" value = { km } onChange = { handleChange } /> < p > { km } km is { convert ( km )} miles < /p> < /div>; } Our Converter component includes a text field, which calls the handleChange function when its value changes. The handleChange function updates the state with the current value of the textfield, causing the component to re-render and show the corresponding miles value, which is calculated using the convert function. The value of the text field is accessed via the e object, which represents the React event. It is passed to the event handler function as an argument and can be used to access the event object.","title":"Handling User Input"},{"location":"js_react/#forms","text":"In the previous part, we learned how to handle user input in text fields. Text fields are usually part of a form. Similar to the previous example, React form elements keep their state and update it based on user input. This way you always have the data of your form at your disposal in the state. To demonstrate this, we will create a form, that will add numbers every time the form is submitted and display the sum. Our form contains an input field and a submit button: function AddForm () { const [ sum , setSum ] = useState ( 0 ); const [ num , setNum ] = useState ( 0 ); function handleChange ( e ) { setNum ( e . target . value ); } function handleSubmit ( e ) { setSum ( sum + Number ( num )); e . preventDefault (); } return < form onSubmit = { handleSubmit } > < input type = \"number\" value = { num } onChange = { handleChange } /> < input type = \"submit\" value = \"Add\" /> < p > Sum is { sum } < /p> < /form>; } In the code above, the value of the input is controlled by React (we keep the value in the state). When the form is submitted using the submit button, the handleSubmit function gets called, which updates the value of sum in the state. An input form element whose value is controlled by React in this way is called a \"controlled component\". Notice the e.preventDefault(); statement. This statement prevents the default behavior of the form, which, by default, reloads the page when submitted. In JavaScript we would use return false; for that, but in React we need to call preventDefault().","title":"Forms"},{"location":"js_react/#lists","text":"Web apps commonly contain repeating elements, such as lists or sections, where the same DOM element is repeated with a different data set. Consider an array of strings: const arr = [ \"A\" , \"B\" , \"C\" ]; We need to render a list element for each item in the array. We can define a MyList component and pass it the array as a prop using a custom data attribute: < MyList data = { arr } /> Now, when the array is accessible via props, we can write the component logic: function MyList ( props ) { const arr = props . data ; const listItems = arr . map (( val ) => < li > { val } < /li> ); return < ul > { listItems } < /ul>; } We take the input array from the incoming props, loop through the array using the JavaScript map function and return a <li> element for each item. The resulted array is stored in the listItems variable. Then, the component returns the listItems array inside a <ul> tag. This code results in a warning, saying that each element needs a unique key","title":"Lists"},{"location":"js_react/#keys","text":"Each element in a list must have a key attribute. Keys act as a unique identity, identifying each element. Usually, these are IDs from your data, or can be auto-generated indexes. For example: const listItems = arr . map (( val , index ) => < li key = { index } > { val } < /li> ); Keys are important, because they uniquely identify elements, helping React understand which items have changed, are added, or are removed. Example : Contact Manager Let's build a contact manager app. We will use a form to add new contacts to the list and display them in a list.","title":"Keys"},{"location":"js_react/#addpersonform","text":"Our AddPersonForm component uses state to manage the value of the text field: function AddPersonForm () { const [ person , setPerson ] = useState ( \"\" ); function handleChange ( e ) { setPerson ( e . target . value ); } function handleSubmit ( e ) { e . preventDefault (); } return ( < form onSubmit = { handleSubmit } > < input type = \"text\" placeholder = \"Add new contact\" onChange = { handleChange } value = { person } /> < button type = \"submit\" > Add < /button> < /form> ); } For now, we just prevent the default behavior when the form is submitted. PeopleList received an array representing the contacts and renders a list on the page: function PeopleList ( props ) { const arr = props . data ; const listItems = arr . map (( val , index ) => < li key = { index } > { val } < /li> ); return < ul > { listItems } < /ul>; } Now we can render our components on the page and include some initial data: const contacts = [ \"James Smith\" , \"Thomas Anderson\" , \"Bruce Wayne\" ]; const el = ( < div > < AddPersonForm /> < PeopleList data = { contacts } /> < /div> ); ReactDOM . render ( el , document . getElementById ( \"root\" )); Adding a new contact does not work, as we have not built the logic in the handleSubmit function yet.","title":"AddPersonForm"},{"location":"js_react/#sharing-state","text":"Right now, our AddPersonForm independently keeps its state. How can we add a new contact to our PeopleList then, when the form is submitted? To accomplish that, we need to share the state between the components. We can do that by lifting the state up to a parent component. This means that the parent component will hold the data that needs to be shared between the components. In our case, that is the contacts list. Let's create a parent component called ContactManager, which includes the AddPersonForm and PeopleList as child components and holds the contacts list in its state: function ContactManager ( props ) { const [ contacts , setContacts ] = useState ( props . data ); return ( < div > < AddPersonForm /> < PeopleList data = { contacts } /> < /div> ); } The ContactManager component receives the initial contacts list using props, saves it in its state. Then it passes down the contacts list to its child component. Data can be passed from the parent to the child, but not from the child to the parent. React uses what is called unidirectional data flow, in other words, data only flows downward, so to speak.","title":"Sharing State"},{"location":"js_react/#adding-a-contact","text":"Now, we can create an addPerson() function to our ContactManager component to add a new person to our contacts state array: function ContactManager ( props ) { const [ contacts , setContacts ] = useState ( props . data ); function addPerson ( name ) { setContacts ([... contacts , name ]); } ... } But how are we going to call this function from our child AddPersonForm component, where the data for the new person is stored? Just like we passed down data using props, React allows us to pass down function references! function ContactManager ( props ) { const [ contacts , setContacts ] = useState ( props . data ); function addPerson ( name ) { setContacts ([... contacts , name ]); } return ( < div > < AddPersonForm handleSubmit = { addPerson } /> < PeopleList data = { contacts } /> < /div> ); } Similar to passing the contacts list to our PeopleList component, we passed down the addPerson() function to our AddPersonForm using a prop called handleSubmit. Now, our PeopleList can call the handleSubmit function that it received when the form is submitted, to add a new person to the list: function AddPersonForm ( props ) { const [ person , setPerson ] = useState ( '' ); function handleChange ( e ) { setPerson ( e . target . value ); } function handleSubmit ( e ) { props . handleSubmit ( person ); setPerson ( '' ); e . preventDefault (); } return ( < form onSubmit = { handleSubmit } > < input type = \"text\" placeholder = \"Add new contact\" onChange = { handleChange } value = { person } /> < button type = \"submit\" > Add < /button> < /form> ); } We also clear the value of the text field using setPerson('') after adding a new person.","title":"Adding a Contact"},{"location":"js_react/#summary","text":"An important takeaway from this lesson is that props can be used to pass down not only state, but also functions, that may manipulate the state. This way, we are able to store the application state in the parent and allow its child components to use and manipulate the state. Now, when our app is fully functional, we can add some CSS styles and a check, to prevent creation of blank contacts.","title":"Summary"},{"location":"js_redux/","text":"Intro to Redux State Management In the real world with larger scale applications, we might have to pass down the state data multiple levels to get to the desired component. Having to pass down data to multiple levels of nested components would make it hard to understand what caused a change to the state, as there might be multiple potential components that can change the state. This would also cause a lot of redundant code, make it hard to maintain and debug the code. Redux was created to make state management predictable, providing a single state container and strict rules on how state can be changed. Redux is a small JavaScript library and can be used with any front-end framework, such as React, Angular, jQuery. It employs the \"single source of truth\" pattern. In short, single source of truth just refers to relocating the application state and all associated logic outside of the application, allowing ANY component to access the data it needs. Having a single state container makes it easier to manage the state of your application, as you can access and change the data from any component that needs it, without having to pass down the data. Core Concepts Single source of truth The global state of the app is stored in a single store. State is read-only You can change the state only by dispatching actions. Action are objects, that contain information about what should be changed. Pure reducers Reducers are functions that handle the actions and return the next state of the application. Reducers need to be pure, meaning they cannot modify the state, they need to return a new state object. Store In Redux, the application's state is stored as a simple object, called store. There should only be a single store in an app. For example, a store can look like this: { contacts : [{ name : 'David' }, { name : 'Amy' }], toggle : true } You cannot change the state directly. Instead, you need to dispatch an action. Actions & Reducers An action is just a plain JavaScript object: { type : 'ADD_CONTACT' , name : 'James' } The code above defines an action with type ADD_CONTACT and a name property. An action clearly describes why the state change happened, and can be dispatched from anywhere in your app. At this point we just have a store, which includes our state data and an object, that includes some data that needs to be changed in the state. So, how do we actually do the change? To tie the store and the action together, we need to write a function, called a reducer. It takes state and action as arguments, and returns the next state of the app. For example: function contactsApp ( state , action ) { if ( action . type === 'ADD_CONTACT' ) { return [ ... state , action . name ] } else { return state } } The code above defines a simple reducer function, that checks the action and returns the new state. These concepts are basically the idea of Redux: you hold the global state in a store, define actions to describe what to change in the store and write reducer functions to handle those actions. Notice, we have not touched any React specific syntax, all of the above is plain JavaScript. Action Creators In order to use the same action with different payloads, as well as create reusable code, we can create Action creators. Action creators are simple functions that return actions. For example: function addContact ( person ) { return { type : 'ADD_CONTACT' , payload : person } } The action creator function takes a person parameter and uses that as the actions payload. Now, we can use the action creator to create multiple new contacts by passing it the corresponding data. Action creators are not built into the Redux library by default. It is a pattern that was implemented to create code that reflects a more DRY (Don't Repeat Yourself) approach. Reducer Function Reducers are functions that handle the actions. The function takes the current state and the action as its parameters and returns the new state. A reducer can handle multiple actions, so usually it includes a switch statement for each action case. For example: function contactsApp ( state , action ) { switch ( action . type ) { case 'ADD_CONTACT' : return [ ... state , action . person ] default : return state } } In the code above, our reducer function uses a switch statement to handle the appropriate actions. As the default case, it just returns the current state. Remember, the reducer has to be a pure function, meaning it cannot modify the current state. It has to return a new state object instead. The default case is added for handling unknown actions. Multiple Reducers If you have more than one entity (i.e. users, products, invoices, orders, etc.), it's typically a good idea to break them into multiple reducer functions to separate concerns. Redux gives us a method that we can use called combineReducers. This allows us to use more than one reducer so that when an action gets dispatched, the action would get run through all of the reducers instead of only one. It also allows us to separate the concerns of our store state. For example: const contactsApp = combineReducers ({ addContacts , doSomething }) Now, our contactsApp is combining two reducers into one. It's a good practice to provide each reducer only the part of the state that it needs to manage. This is called reducer composition, and is a fundamental pattern of building Redux apps. Redux with React Now, that we know what Redux is, we can start building React apps that use Redux! First, we need to install Redux: npm install redux This will install the Redux library. However, Redux itself is just a small library, that can be used with different technologies. To use it with React, we need to install another library, called react-redux: npm install react-redux The react-redux library binds React with Redux, allowing React components to read data from a Redux store, and dispatch actions to the store to update data. Counter App As our first example, let's build the Counter app we made in the previous module using Redux! First, we need to create our action and corresponding reducer. function incrementCounter ( num ) { return { type : 'INCREMENT' , num : num } } The code above declares an action creator function named incrementCounter(), which returns an action with type INCREMENT and the corresponding payload. Our reducer: const initialState = { count : 0 }; function reducer ( state = initialState , action ) { switch ( action . type ) { case 'INCREMENT' : return { count : state . count + action . num }; default : return state ; } } The code above defines a reducer function, which returns the new state based on the given action. We increment the count state variable by the provided num value. We also provide a default value for our state using the initialState variable. Nothing fancy until now, we just created two simple functions, one returning our action object, the other one returning a new state with the incremented count. Creating the Store To create the store, we call the createStore() function, which takes the reducer as its parameter: const store = createStore ( reducer ); But how do we pass the store to our components? That is achieved using a special <Provider> element. It makes the store available to any nested child component. So, for our counter, we would have the following: const el = < Provider store = { store } > < Counter /> < /Provider>; Provider takes the store as an attribute and makes it available to its child component. We need to import { createStore } and { Provider } using the following syntax: import { Provider } from 'react-redux' ; import { createStore } from 'redux' ; Connecting to the Store At this point, we have created our action, the reducer, the store, and made it available to our Counter component using the Provider element. In order to connect our component to the store, we need to call the connect() function. The connect() function returns a new component, that wraps the component you passed to it and connects it to the store using its special parameter functions. function connect(mapStateToProps?, mapDispatchToProps?) connect() takes two optional parameters: mapStateToProps This function is called every time the store state changes. It receives the state as a parameter and returns the state for the component. For example, for our Counter, we need to return the count state variable: function mapStateToProps ( state ) { return { count : state . count }; } Now, our component can access the count variable using its props! Just as the name of the function states, it maps the state to the props. mapDispatchToProps As you may have guessed from the name, this parameter is used to map the dispatch functions to props. It can be a simple object, defining the function that needs to be mapped: const mapDispatchToProps = { incrementCounter } This might seem a bit confusing, but its very straightforward: mapStateToProps simply returns the state variables as props to our component, while mapDispatchToProps allows to define how we dispatch actions and make the dispatching functions available as props. Both are optional, as, for example, your component might only need to read from the store. mapDispatchToProps can also be defined as a function. Take a look at the official documentation for more details. Note, that we need to import the connect function: import { connect } from 'react-redux'; Accessing The Store Inside our component we just access the store properties using props function Counter ( props ) { function handleClick () { props . incrementCounter ( 1 ); } return < div > < p > { props . count } < /p> < button onClick = { handleClick } > Increment < /button> < /div>; } Notice, that we pass 1 as the argument to our incrementCounter(), making our counter increment by 1. We can change the value to any other number, and our counter will behave as expected, because we handled the increment parameter in our reducer. Now, the only thing left is to call the connect() function for our Counter component and render it on the page: const Counter = connect ( mapStateToProps , mapDispatchToProps )( Counter ); const el = < Provider store = { store } > < Counter /> < /Provider>; Remember, connect() returns a new component, which wraps the component it received. Now we have a fully functional React+Redux app! This might seem too much code for a simple counter app, however this architecture is great when building large scale apps, that use many components, multiple levels of nesting and manage a lot of data. Project Structure To make our project more manageable, we can use separate source files (and folders) for components, reducers and actions. For example, we can move our Counter component and the action creator function to a separate Counter.js file. In order to use the Counter component in our index.js, we need to export it first: export default connect ( mapStateToProps , mapDispatchToProps )( Counter ); Notice, we export the connected component. Now, we can import the component in index.js: import Counter from './Counter' ; We use the ES6 modules system, which allows use to export and import modules.","title":"Redux"},{"location":"js_redux/#intro-to-redux","text":"","title":"Intro to Redux"},{"location":"js_redux/#state-management","text":"In the real world with larger scale applications, we might have to pass down the state data multiple levels to get to the desired component. Having to pass down data to multiple levels of nested components would make it hard to understand what caused a change to the state, as there might be multiple potential components that can change the state. This would also cause a lot of redundant code, make it hard to maintain and debug the code. Redux was created to make state management predictable, providing a single state container and strict rules on how state can be changed. Redux is a small JavaScript library and can be used with any front-end framework, such as React, Angular, jQuery. It employs the \"single source of truth\" pattern. In short, single source of truth just refers to relocating the application state and all associated logic outside of the application, allowing ANY component to access the data it needs. Having a single state container makes it easier to manage the state of your application, as you can access and change the data from any component that needs it, without having to pass down the data.","title":"State Management"},{"location":"js_redux/#core-concepts","text":"Single source of truth The global state of the app is stored in a single store. State is read-only You can change the state only by dispatching actions. Action are objects, that contain information about what should be changed. Pure reducers Reducers are functions that handle the actions and return the next state of the application. Reducers need to be pure, meaning they cannot modify the state, they need to return a new state object.","title":"Core Concepts"},{"location":"js_redux/#store","text":"In Redux, the application's state is stored as a simple object, called store. There should only be a single store in an app. For example, a store can look like this: { contacts : [{ name : 'David' }, { name : 'Amy' }], toggle : true } You cannot change the state directly. Instead, you need to dispatch an action.","title":"Store"},{"location":"js_redux/#actions-reducers","text":"An action is just a plain JavaScript object: { type : 'ADD_CONTACT' , name : 'James' } The code above defines an action with type ADD_CONTACT and a name property. An action clearly describes why the state change happened, and can be dispatched from anywhere in your app. At this point we just have a store, which includes our state data and an object, that includes some data that needs to be changed in the state. So, how do we actually do the change? To tie the store and the action together, we need to write a function, called a reducer. It takes state and action as arguments, and returns the next state of the app. For example: function contactsApp ( state , action ) { if ( action . type === 'ADD_CONTACT' ) { return [ ... state , action . name ] } else { return state } } The code above defines a simple reducer function, that checks the action and returns the new state. These concepts are basically the idea of Redux: you hold the global state in a store, define actions to describe what to change in the store and write reducer functions to handle those actions. Notice, we have not touched any React specific syntax, all of the above is plain JavaScript.","title":"Actions &amp; Reducers"},{"location":"js_redux/#action-creators","text":"In order to use the same action with different payloads, as well as create reusable code, we can create Action creators. Action creators are simple functions that return actions. For example: function addContact ( person ) { return { type : 'ADD_CONTACT' , payload : person } } The action creator function takes a person parameter and uses that as the actions payload. Now, we can use the action creator to create multiple new contacts by passing it the corresponding data. Action creators are not built into the Redux library by default. It is a pattern that was implemented to create code that reflects a more DRY (Don't Repeat Yourself) approach.","title":"Action Creators"},{"location":"js_redux/#reducer-function","text":"Reducers are functions that handle the actions. The function takes the current state and the action as its parameters and returns the new state. A reducer can handle multiple actions, so usually it includes a switch statement for each action case. For example: function contactsApp ( state , action ) { switch ( action . type ) { case 'ADD_CONTACT' : return [ ... state , action . person ] default : return state } } In the code above, our reducer function uses a switch statement to handle the appropriate actions. As the default case, it just returns the current state. Remember, the reducer has to be a pure function, meaning it cannot modify the current state. It has to return a new state object instead. The default case is added for handling unknown actions.","title":"Reducer Function"},{"location":"js_redux/#multiple-reducers","text":"If you have more than one entity (i.e. users, products, invoices, orders, etc.), it's typically a good idea to break them into multiple reducer functions to separate concerns. Redux gives us a method that we can use called combineReducers. This allows us to use more than one reducer so that when an action gets dispatched, the action would get run through all of the reducers instead of only one. It also allows us to separate the concerns of our store state. For example: const contactsApp = combineReducers ({ addContacts , doSomething }) Now, our contactsApp is combining two reducers into one. It's a good practice to provide each reducer only the part of the state that it needs to manage. This is called reducer composition, and is a fundamental pattern of building Redux apps.","title":"Multiple Reducers"},{"location":"js_redux/#redux-with-react","text":"Now, that we know what Redux is, we can start building React apps that use Redux! First, we need to install Redux: npm install redux This will install the Redux library. However, Redux itself is just a small library, that can be used with different technologies. To use it with React, we need to install another library, called react-redux: npm install react-redux The react-redux library binds React with Redux, allowing React components to read data from a Redux store, and dispatch actions to the store to update data.","title":"Redux with React"},{"location":"js_redux/#counter-app","text":"As our first example, let's build the Counter app we made in the previous module using Redux! First, we need to create our action and corresponding reducer. function incrementCounter ( num ) { return { type : 'INCREMENT' , num : num } } The code above declares an action creator function named incrementCounter(), which returns an action with type INCREMENT and the corresponding payload. Our reducer: const initialState = { count : 0 }; function reducer ( state = initialState , action ) { switch ( action . type ) { case 'INCREMENT' : return { count : state . count + action . num }; default : return state ; } } The code above defines a reducer function, which returns the new state based on the given action. We increment the count state variable by the provided num value. We also provide a default value for our state using the initialState variable. Nothing fancy until now, we just created two simple functions, one returning our action object, the other one returning a new state with the incremented count.","title":"Counter App"},{"location":"js_redux/#creating-the-store","text":"To create the store, we call the createStore() function, which takes the reducer as its parameter: const store = createStore ( reducer ); But how do we pass the store to our components? That is achieved using a special <Provider> element. It makes the store available to any nested child component. So, for our counter, we would have the following: const el = < Provider store = { store } > < Counter /> < /Provider>; Provider takes the store as an attribute and makes it available to its child component. We need to import { createStore } and { Provider } using the following syntax: import { Provider } from 'react-redux' ; import { createStore } from 'redux' ;","title":"Creating the Store"},{"location":"js_redux/#connecting-to-the-store","text":"At this point, we have created our action, the reducer, the store, and made it available to our Counter component using the Provider element. In order to connect our component to the store, we need to call the connect() function. The connect() function returns a new component, that wraps the component you passed to it and connects it to the store using its special parameter functions.","title":"Connecting to the Store"},{"location":"js_redux/#accessing-the-store","text":"Inside our component we just access the store properties using props function Counter ( props ) { function handleClick () { props . incrementCounter ( 1 ); } return < div > < p > { props . count } < /p> < button onClick = { handleClick } > Increment < /button> < /div>; } Notice, that we pass 1 as the argument to our incrementCounter(), making our counter increment by 1. We can change the value to any other number, and our counter will behave as expected, because we handled the increment parameter in our reducer. Now, the only thing left is to call the connect() function for our Counter component and render it on the page: const Counter = connect ( mapStateToProps , mapDispatchToProps )( Counter ); const el = < Provider store = { store } > < Counter /> < /Provider>; Remember, connect() returns a new component, which wraps the component it received. Now we have a fully functional React+Redux app! This might seem too much code for a simple counter app, however this architecture is great when building large scale apps, that use many components, multiple levels of nesting and manage a lot of data.","title":"Accessing The Store"},{"location":"js_redux/#project-structure","text":"To make our project more manageable, we can use separate source files (and folders) for components, reducers and actions. For example, we can move our Counter component and the action creator function to a separate Counter.js file. In order to use the Counter component in our index.js, we need to export it first: export default connect ( mapStateToProps , mapDispatchToProps )( Counter ); Notice, we export the connected component. Now, we can import the component in index.js: import Counter from './Counter' ; We use the ES6 modules system, which allows use to export and import modules.","title":"Project Structure"}]}